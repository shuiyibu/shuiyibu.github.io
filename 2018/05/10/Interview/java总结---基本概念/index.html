<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="TestNG,Spring Boot,">





  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">






<meta name="description" content="1 操作系统中 heap 和 stack 的区别https://blog.csdn.net/u014306011/article/details/51044091  堆栈的概念：  堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，">
<meta name="keywords" content="TestNG,Spring Boot">
<meta property="og:type" content="article">
<meta property="og:title" content="java总结---基本概念">
<meta property="og:url" content="http://yoursite.com/2018/05/10/Interview/java总结---基本概念/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 操作系统中 heap 和 stack 的区别https://blog.csdn.net/u014306011/article/details/51044091  堆栈的概念：  堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdn.net/20130818152510875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvemhhbmd5aW5nZmVpMDEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-05-15T07:37:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java总结---基本概念">
<meta name="twitter:description" content="1 操作系统中 heap 和 stack 的区别https://blog.csdn.net/u014306011/article/details/51044091  堆栈的概念：  堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，">
<meta name="twitter:image" content="https://img-blog.csdn.net/20130818152510875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvemhhbmd5aW5nZmVpMDEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/10/Interview/java总结---基本概念/">





  <title>java总结---基本概念 | Hexo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4d5b541690a836307558f5f13157a238";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/Interview/java总结---基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dylan Lang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">java总结---基本概念</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-10T11:40:20+08:00">
                2018-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/10/Interview/java总结---基本概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/05/10/Interview/java总结---基本概念/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h3 id="1-操作系统中-heap-和-stack-的区别"><a href="#1-操作系统中-heap-和-stack-的区别" class="headerlink" title="1 操作系统中 heap 和 stack 的区别"></a>1 操作系统中 <code>heap</code> 和 <code>stack</code> 的区别</h3><p><a href="https://blog.csdn.net/u014306011/article/details/51044091" target="_blank" rel="noopener">https://blog.csdn.net/u014306011/article/details/51044091</a></p>
<ul>
<li><p>堆栈的概念：</p>
<blockquote>
<p>堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（<code>FIFO—first in first out</code>）。栈，先进后出(<code>FILO—First-In/Last-Out</code>)。</p>
</blockquote>
</li>
<li><p><strong>堆和栈的区别</strong>：</p>
<ul>
<li><p><code>堆栈空间分配区别</code>：<br>　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；<br>　　2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
</li>
<li><p><code>堆栈缓存方式区别</code>：<br>　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；<br>　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
</li>
<li><p><code>堆栈数据结构区别</code>：<br>　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>　　栈（数据结构）：一种先进后出的数据结构。</p>
</li>
</ul>
</li>
<li><p>Java中栈和堆的区别：</p>
<ul>
<li>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</li>
<li>在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</li>
<li>堆内存用来存放由<code>new</code>创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</li>
<li><strong>Java中变量在内存中的分配</strong>：<br>　　1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭。<br>　　2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。<br>　　3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。<br>这里要涉及到Java内存问题，可以参考：<a href="http://blog.csdn.net/u014306011/article/details/51068495" target="_blank" rel="noopener">Java的内存机制</a></li>
</ul>
</li>
</ul>
<h3 id="2-什么是基于注解的切面实现"><a href="#2-什么是基于注解的切面实现" class="headerlink" title="2 什么是基于注解的切面实现"></a>2 什么是基于注解的切面实现</h3><ul>
<li><a href="https://blog.csdn.net/program_guys/article/details/78724090" target="_blank" rel="noopener">https://blog.csdn.net/program_guys/article/details/78724090</a></li>
<li><a href="https://blog.csdn.net/qq_33517844/article/details/77371358" target="_blank" rel="noopener">https://blog.csdn.net/qq_33517844/article/details/77371358</a></li>
<li><a href="https://blog.csdn.net/zouqingfang/article/details/50728567" target="_blank" rel="noopener">https://blog.csdn.net/zouqingfang/article/details/50728567</a></li>
<li><a href="http://www.cnblogs.com/lxnlxn/p/5868495.html" target="_blank" rel="noopener">http://www.cnblogs.com/lxnlxn/p/5868495.html</a></li>
</ul>
<h3 id="3-什么是-对象-关系-映射集成模块"><a href="#3-什么是-对象-关系-映射集成模块" class="headerlink" title="3 什么是 对象/关系 映射集成模块"></a>3 什么是 对象/关系 映射集成模块</h3><ul>
<li><p>什么是<code>对象/关系 映射</code><br>对象关系映射，简单讲就是Java对象 Object 和关系型数据库 Relationship 之间的映射Mapping， 即ORM。</p>
</li>
<li><p>为什么要使用ORM？<br>因为面向对象的概念，使得操作关系型数据库也可以用操作对象那样处理。操作关系型数据库，就像操作Java对象一样，更容易以面向对象的方式理解。</p>
</li>
<li><p>ORM框架<br>常见的ORM框架有：Hibernate、TopLink、Castor JDO、Apache OJB等</p>
</li>
<li><p>ORM实现原理<br>先说ORM的实现原理，其实，要实现JavaBean的属性到数据库表的字段的映射，任何ORM框架不外乎是读某个配置文件把JavaBean的属性和数据库表的字段自动关联起来，当从数据库Query时，自动把字段的值塞进JavaBean的对应属性里，当做INSERT或UPDATE时，自动把JavaBean的属性值绑定到SQL语句中。</p>
</li>
</ul>
<h3 id="4-什么是-Java-的反射机制"><a href="#4-什么是-Java-的反射机制" class="headerlink" title="4 什么是 Java 的反射机制"></a>4 什么是 <code>Java</code> 的反射机制</h3><ul>
<li><a href="https://www.zhihu.com/question/24304289" target="_blank" rel="noopener">https://www.zhihu.com/question/24304289</a></li>
<li><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/java-reflection-1/</a></li>
<li><a href="https://www.sczyh30.com/posts/Java/java-reflection-2/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/java-reflection-2/</a></li>
<li><a href="https://www.jianshu.com/p/5110834f669f" target="_blank" rel="noopener">https://www.jianshu.com/p/5110834f669f</a></li>
</ul>
<p>反射机制:所谓的反射机制就是java语言在运行时拥有一项自观的能力。通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。</p>
<p>下面具体介绍一下java的反射机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method;</span><br></pre></td></tr></table></figure>
<p>其中class代表的时类对 象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组 成部分。</p>
<p>Java反射的作用：</p>
<p>在Java运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。</p>
<p>Java 反射机制主要提供了以下功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在运行时判断任意一个对象所属的类。</span><br><span class="line">在运行时构造任意一个类的对象。</span><br><span class="line">在运行时判断任意一个类所具有的成员变量和方法。</span><br><span class="line">在运行时调用任意一个对象的方法</span><br></pre></td></tr></table></figure>
<p>反射的常用类和函数:Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；</p>
<p>其中class代表的是类对象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。其中最核心的就是Class类，它是实现反射的基础，它包含的方法我们在第一部分已经进行了基本的阐述。应用反射时我们最关心的一般是一个类的构造器、属性和方法，下面我们主要介绍Class类中针对这三个元素的方法:</p>
<p>1、得到构造器的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Constructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的公共构造函数，</span><br><span class="line"></span><br><span class="line">Constructor[] getConstructors() -- 获得类的所有公共构造函数</span><br><span class="line"></span><br><span class="line">Constructor getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数(与接入级别无关)</span><br><span class="line"></span><br><span class="line">Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数(与接入级别无关)</span><br></pre></td></tr></table></figure>
<p>2、获得字段信息的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field getField(String name) -- 获得命名的公共字段</span><br><span class="line"></span><br><span class="line">Field[] getFields() -- 获得类的所有公共字段</span><br><span class="line"></span><br><span class="line">Field getDeclaredField(String name) -- 获得类声明的命名的字段</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields() -- 获得类声明的所有字段</span><br></pre></td></tr></table></figure>
<p>3、获得方法信息的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method getMethod(String name, Class[] params) -- 使用特定的参数类型，获得命名的公共方法</span><br><span class="line"></span><br><span class="line">Method[] getMethods() -- 获得类的所有公共方法</span><br><span class="line"></span><br><span class="line">Method getDeclaredMethod(String name, Class[] params) -- 使用特写的参数类型，获得类声明的命名的方法</span><br><span class="line"></span><br><span class="line">Method[] getDeclaredMethods() -- 获得类声明的所有方法</span><br></pre></td></tr></table></figure>
<p>在程序开发中使用反射并结合属性文件，可以达到程序代码与配置文件相分离的目的</p>
<p>如果我们想要得到对象的信息，一般需要“引入需要的‘包.类’的名称——通过new实例化——取得实例化对象”这样的过程。使用反射就可以变成“实例化对象——getClass()方法——得到完整的‘包.类’名称”这样的过程。</p>
<p>正常方法是通过一个类创建对象，反射方法就是通过一个对象找到一个类的信息。</p>
<h3 id="5-什么是-ACID"><a href="#5-什么是-ACID" class="headerlink" title="5 什么是 ACID"></a>5 什么是 <code>ACID</code></h3><h3 id="什么是ACID特性，数据库如何保证ACID特性的？"><a href="#什么是ACID特性，数据库如何保证ACID特性的？" class="headerlink" title="什么是ACID特性，数据库如何保证ACID特性的？"></a><strong>什么是ACID特性，数据库如何保证ACID特性的？</strong></h3><p><strong>ACID</strong>，是指在<a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">数据库管理系统</a>（<a href="http://zh.wikipedia.org/wiki/DBMS" target="_blank" rel="noopener">DBMS</a>）中，<strong>事务(transaction)</strong>所具有的四个特性：<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation，又称独立性）</strong>、<strong>持久性（Durability）</strong>。</p>
<p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。ACID的概念在<a href="http://zh.wikipedia.org/wiki/ISO" target="_blank" rel="noopener">ISO</a>/IEC 10026-1:1992文件的第四段內有所說明。</p>
<ul>
<li>原子性：一整个交易中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。交易在执行过程中发生错误，会被回復（Rollback）到交易开始前的状态，就像这个交易从来没有执行过一样。</li>
<li>一致性：在交易开始之前和交易结束以后，数据库的完整性限制没有被破坏。</li>
<li>隔离性：两个交易的执行是互不干扰的，一个交易不可能看到其他交易运行时，中间某一时刻的数据。</li>
<li>持久性：在交易完成以后，该交易对数据库所作的更改便持久地保存在数据库之中，并不会被回復。</li>
</ul>
<p>Oracle中用<strong>锁</strong>、<strong>并发与多版本</strong>（非阻塞读）保持<strong>一致性</strong>和<strong>隔离性</strong>，用事务的commit,rollback,savepoint保持<strong>原子性</strong>，用数据库文件保持持久性，断电后，内存数据丢失，硬盘文件数据不丢失，重启后从文件中加载到内存，保持<strong>持久性</strong></p>
<h3 id="事务的传播特性？"><a href="#事务的传播特性？" class="headerlink" title="事务的传播特性？"></a><strong>事务的传播特性？</strong></h3><p>事务的传播行为<br><strong>REQUIRED</strong>:<br>   业务方法需要在一个事务中运行，如果方法运行时，已经存在一个事务中，那么加入到该事务，否则自己创建一个新事务。<br><strong>NOT_SUPPORTED</strong>:<br>   声明方法不需要事务，如果方法没有关联到事务，容器不会为它开启事务，如果方法在一个事务中被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行。<br><strong>REQUIRESNEW</strong>:<br>  不管是否存在事务，业务方法总为自己发起一个新事务；如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法调用结束，新事务才结束，原先的事务再恢复执行。<br><strong>MANDATORY</strong>：<br>   业务方法只能在一个已经存在的事务中进行，业务方法不能发起自己的事务，如果方法在没有事务的环境中调用，那么容器会抛出例外。<br><strong>SUPPORTS</strong>:<br>   如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分，如果业务方法在事务外被调用，则方法在没有事务的环境下执行。<br><strong>NEVER</strong>:<br>   业务方法绝对不能再事务范围内执行，如果方法在某个事务中执行，容器会抛出例外，只有业务方法没有关联到任何事务，方法才能够正常执行。<br><strong>NESTED</strong>:<br>  如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按照REQUIRED属性执行，它使用了一个单独的事务，这个事务有多个可以回滚的保存点，内部事务的回滚不会对外部事务产生影响。它只对DataSourceTransactionManager事务管理器有效。</p>
<p><strong>事务传播特性了解事务的几种传播特性</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>数据库操作1</strong></th>
<th><strong>数据库操作2</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PROPAGATION_REQUIRED</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Transaction1</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>Transaction2</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_SUPPORTS</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Transaction1</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>null</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_MANDATORY</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Transaction1</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>Throws Exception</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_REQUIRES_NEW</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Transaction2</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>Transaction2</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_NOT_SUPPORTED</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>null</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>null</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_NEVER</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Throws Exception</strong></td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>null</strong></td>
<td></td>
</tr>
<tr>
<td><strong>PROPAGATION_NESTED(Spring)</strong></td>
<td><strong>Transaction1</strong></td>
<td><strong>Transaction2**</strong>[Transaction1]**</td>
</tr>
<tr>
<td><strong>null</strong></td>
<td><strong>Transaction2</strong></td>
</tr>
</tbody>
</table>
<p>​         <strong>1.      PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启</strong></p>
<p>​         <strong>2.      PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</strong></p>
<p>​         <strong>3.      PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</strong></p>
<p>​         <strong>4.      PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</strong></p>
<p>​         <strong>5.      PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务。</strong></p>
<p>​         <strong>6.      PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常</strong></p>
<p>​         <strong>7.      PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务,</strong></p>
<p>​              <strong>则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</strong></p>
<p>-——————————————————————–</p>
<h3 id="事务的隔离级别？"><a href="#事务的隔离级别？" class="headerlink" title="事务的隔离级别？"></a><strong>事务的隔离级别？</strong></h3><p>事务的隔离级别<br>注：Spring中事务的隔离级别是由数据库实现的</p>
<p>ISOLATION_DEFAULT</p>
<p>​    这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.另外四个与JDBC的隔离级别相对应</p>
<p>ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读</p>
<p>ISOLATION_READ_COMMITTED</p>
<p>​    保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p>
<p>ISOLATION_REPEATABLE_READ</p>
<p>​    这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p>
<p>ISOLATION_SERIALIZABLE</p>
<p>​    这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>
<p>脏读：</p>
<p>​    一个事务读取到另一个事务未提交的更新数据。</p>
<p>不可重复读：</p>
<p>​    在同一事务中，多次读取同一数据返回的结果有所不同，即后续读取可以读取到另一事务已提交的更新数据；相反，”可重复读”是指在同一事务中多次读取数据时，能够保证所读取的数据是一样，即后续读取不能读到另一事务已提交的数据。</p>
<p>幻读：</p>
<p>​    一个事务读取到另一事务已提交的insert数据。</p>
<p><strong>事务隔离级别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻象读</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ISOLATION_READ_UNCOMMITTED</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_READ_COMMITTED</strong></td>
<td></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_REPEATABLE_READ</strong></td>
<td></td>
<td></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_SERIALIZABLE</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>ISOLATION_DEFAULT</strong></td>
<td><strong>PlatfromTransactionManager**</strong>默认的隔离级别<strong><strong>SQLServer ：READ_COMMITTED</strong></strong>MySql：REPEATABLE_READ**</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Spring事务的隔离级别</strong></p>
<p>​         <strong>1.      ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</strong></p>
<p>​              <strong>另外四个与JDBC的隔离级别相对应</strong></p>
<p>​         <strong>2.      ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。</strong></p>
<p>​              <strong>这种隔离级别会产生脏读，不可重复读和幻像读。</strong></p>
<p>​         <strong>3.      ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</strong></p>
<p>​         <strong>4.      ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</strong></p>
<p>​         <strong>5.      ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</strong></p>
<p>​              <strong>除了防止脏读，不可重复读外，还避免了幻像读。</strong></p>
<p><strong>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</strong></p>
<p><strong>不可重复读是 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。</strong></p>
<p><strong>那么，在第一个事务中的两次读数据之间，由于第二个事务的修 改，那么第一个事务两次读到的的数据可能是不一样的。</strong></p>
<p><strong>幻觉读是 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行</strong></p>
<p><strong>。同时，第二个事务也修改这个表中的 数据，这种修改是向表中插入一行新数据。</strong></p>
<p>那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<p>其他关于事务的url:</p>
<p>事务的传播性和隔离级别<br><a href="http://blog.csdn.net/puyun9494/archive/2010/05/11/5579273.aspx" target="_blank" rel="noopener">http://blog.csdn.net/puyun9494/archive/2010/05/11/5579273.aspx</a></p>
<p>数据库事务的隔离级别<br><a href="http://www.kingbase.com.cn/BBS/dispbbs.asp?boardid=11&amp;Id=50" target="_blank" rel="noopener">http://www.kingbase.com.cn/BBS/dispbbs.asp?boardid=11&amp;Id=50</a><br><a href="http://www.itpub.net/thread-914687-1-1.html" target="_blank" rel="noopener">http://www.itpub.net/thread-914687-1-1.html</a>#</p>
<h3 id="6-BS与CS的联系与区别"><a href="#6-BS与CS的联系与区别" class="headerlink" title="6 BS与CS的联系与区别"></a>6 <code>BS</code>与<code>CS</code>的联系与区别</h3><ul>
<li><a href="https://blog.csdn.net/caozhangyingfei0109/article/details/10046745" target="_blank" rel="noopener">https://blog.csdn.net/caozhangyingfei0109/article/details/10046745</a></li>
</ul>
<p>如果要比较两种事物之间的相同点和不同点，首先，我们要分别对这两种事物有一个最基本的了解。</p>
<h1 id="一、C-S与B-S的定义"><a href="#一、C-S与B-S的定义" class="headerlink" title="一、C/S与B/S的定义"></a>一、C/S与B/S的定义</h1><ul>
<li>C/S (<strong>Client/Server</strong>)结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。</li>
<li>B/S（<strong>Browser/Server</strong>）结构即浏览器和服务器结构。它是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端（Browser）实现，但是主要事务逻辑在服务器端（Server）实现，形成所谓三层3-tier结构。这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本（TCO）。</li>
</ul>
<h1 id="二、（C-S）-VS-（B-S-）"><a href="#二、（C-S）-VS-（B-S-）" class="headerlink" title="二、（C/S）   VS  （B/S ）"></a>二、（C/S）   VS  （B/S ）</h1><ol>
<li><h2 id="简单的用一张图来表示两者的区别："><a href="#简单的用一张图来表示两者的区别：" class="headerlink" title="简单的用一张图来表示两者的区别："></a>简单的用一张图来表示两者的区别：</h2></li>
</ol>
<p><img src="https://img-blog.csdn.net/20130818152510875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2Fvemhhbmd5aW5nZmVpMDEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<ol>
<li><h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2></li>
</ol>
<ul>
<li><h3 id="C-S的优缺点："><a href="#C-S的优缺点：" class="headerlink" title="C/S的优缺点："></a>C/S的优缺点：</h3></li>
</ul>
<p>   <strong>C/S的最大优点是能够实现复杂的应用构造，安全性高，数据传输速度快。</strong></p>
<p>（1）、应用服务器运行数据负荷较轻。</p>
<p>最简单的C/S体系结构的数据库应用由两部分组成，即客户应用程序和数据库服务器程序。二者可分别称为前台程序与后台程序。运行数据库服务器程序的机器，也称为应用服务器。一旦服务器程序被启动，就随时等待响应客户程序发来的请求；客户应用程序运行在用户自己的电脑上，对应于数据库服务器，可称为客户电脑，当需要对数据库中的数据进行任何操作时，客户程序就自动地寻找服务器程序，并向其发出请求，服务器程序根据预定的规则作出应答，送回结果，应用服务器运行数据负荷较轻。</p>
<p>（2）、数据的储存管理功能较为透明。</p>
<p>在数据库应用中，数据的储存管理功能，是由服务器程序和客户应用程序分别独立进行的，前台应用可以违反的规则，并且通常把那些不同的（不管是已知还是未知的）运行数据，在服务器程序中不集中实现，例如访问者的权限，编号可以重复、必须有客户才能建立定单这样的规则。所有这些，对于工作在前台程序上的最终用户，是“透明”的，他们无须过问（通常也无法干涉）背后的过程，就可以完成自己的一切工作。在客户服务器架构的应用中，前台程序不是非常“瘦小”，麻烦的事情都交给了服务器和网络。在C/S体系的下，数据库不能真正成为公共、专业化的仓库，它受到独立的专门管理。</p>
<p>（3）、C/S架构的劣势是高昂的维护成本且投资大。</p>
<p>首先，采用C/S架构，要选择适当的数据库平台来实现数据库数据的真正“统一”，使分布于两地的数据同步完全交由数据库系统去管理，但逻辑上两地的操作者要直接访问同一个数据库才能有效实现，有这样一些问题，如果需要建立“实时”的数据同步，就必须在两地间建立实时的通讯连接，保持两地的数据库服务器在线运行，网络管理工作人员既要对服务器维护管理，又要对客户端维护和管理，这需要高昂的投资和复杂的技术支持，维护成本很高，维护任务量大。其次，传统的C/S结构的软件需要针对不同的操作系统系统开发不同版本的软件，由于产品的更新换代十分快，代价高和低效率已经不适应工作需要。在JAVA这样的跨平台语言出现之后，B/S架构更是猛烈冲击C/S，并对其形成威胁和挑战。</p>
<ul>
<li><h3 id="B-S的优缺点："><a href="#B-S的优缺点：" class="headerlink" title="B/S的优缺点："></a>B/S的优缺点：</h3></li>
</ul>
<p><strong>B/S最大的优点就是可以在任何地方进行操作而不用安装任何专门的软件，只要有一台能上网的电脑就能使用，</strong><a href="http://baike.baidu.com/view/930.htm" target="_blank" rel="noopener"><strong>客户端</strong></a><strong>零安装、零维护。系统的扩展非常容易。</strong></p>
<p>（1）、维护和升级方式简单。</p>
<p> 目前，软件系统的改进和升级越来越频繁，B/S架构的产品明显体现着更为方便的特性。对一个稍微大一点单位来说，系统管理人员如果需要在几百甚至上千部电脑之间来回奔跑，效率和工作量是可想而知的，但B/S架构的软件只需要管理服务器就行了，所有的客户端只是浏览器，根本不需要做任何的维护。无论用户的规模有多大，有多少分支机构都不会增加任何维护升级的工作量，所有的操作只需要针对服务器进行；如果是异地，只需要把服务器连接专网即可，实现远程维护、升级和共享。所以客户机越来越“瘦”，而服务器越来越“胖”是将来信息化发展的主流方向。今后，软件升级和维护会越来越容易，而使用起来会越来越简单，这对用户人力、物力、时间、费用的节省是显而易见的，惊人的。因此，维护和升级革命的方式是“瘦”客户机，“胖”服务器。</p>
<p>（2）、成本降低，选择更多。</p>
<p>大家都知道windows在桌面电脑上几乎一统天下，浏览器成为了标准配置，但在服务器操作系统上windows并不是处于绝对的统治地位。现在的趋势是凡使用B/S架构的应用管理软件，只需安装在Linux服务器上即可，而且安全性高。所以服务器操作系统的选择是很多的，不管选用那种操作系统都可以让大部分人使用windows作为桌面操作系统电脑不受影响，这就使的最流行免费的Linux操作系统快速发展起来，Linux除了操作系统是免费的以外，连数据库也是免费的，这种选择非常盛行。比如说很多人每天上“网易”（原文为新浪）网，只要安装了浏览器就可以了，并不需要了解“网易”的服务器用的是什么操作系统，而事实上大部分网站确实没有使用windows操作系统，但用户的电脑本身安装的大部分是windows操作系统。</p>
<p>（3）、应用服务器运行数据负荷较重。</p>
<p>由于B/S架构管理软件只安装在服务器端（Server）上，网络管理人员只需要管理服务器就行了，用户界面主要事务逻辑在服务器（Server）端完全通过WWW浏览器实现，极少部分事务逻辑在前端（Browser）实现，所有的客户端只有浏览器，网络管理人员只需要做硬件维护。但是，应用服务器运行数据负荷较重，一旦发生服务器“崩溃”等问题，后果不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。</p>
<h1 id="三、追本溯源"><a href="#三、追本溯源" class="headerlink" title="三、追本溯源"></a>三、追本溯源</h1><p>必须强调：C/S和B/S并没有本质的区别：B/S是基于特定通信协议(HTTP)的C/S架构，也就是说B/S包含在C/S中，是<strong>特殊的C/S架构</strong>。</p>
<p>之所以在C/S架构上提出B/S架构，是为了满足瘦客户端、一体化客户端的需要，最终目的节约客户端更新、维护等的成本，及广域资源的共享。</p>
<ol>
<li><p>B/S属于C/S，浏览器只是特殊的客户端；</p>
</li>
<li><p>C/S可以使用任何通信协议，而B/S这个特殊的C/S架构规定必须实现HTTP协议；</p>
</li>
<li><p>浏览器是一个通用客户端，本质上开发浏览器，还是实现一个C/S系统。</p>
</li>
</ol>
<p>​        C/S和B/S是当今世界开发模式技术架构的两大主流技术。C/S是美国 Borland公司最早研发，B/S是美国微软公司研发。目前，这两项技术以被世界各国所掌握，这两种技术都有自己一定的市场份额和客户群。</p>
<p>​        我们不能简单的说是C/S还是B/S好，B／S结构的主要特点是分布性强、维护方便、开发简单且共享性强、总体拥有成本低。但数据安全性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。虽然可以用ActiveX、Java等技术开发较为复杂的应用，但是相对于发展已非常成熟C／S的一系列应用工具来说，这些技术的开发复杂，并没有完全成熟的技术工具供使用。只能说两种开发模式各有优缺点和使用的范围：B/S适用于用户群庞大，或客户需求经长发生变化的情况。C/S功能强大，可以减轻服务器端压力，如果用户的需求特别复杂，用C/S。</p>
<p>​          但是随着Windows将浏览器技术植入操作系统内部，B/S结构已越来越受到欢迎，客户机越来越”瘦”而服务器越来越”胖”是将来软件的主流发展方向。</p>
<h3 id="7-Cookie-和-Session的区别"><a href="#7-Cookie-和-Session的区别" class="headerlink" title="7 Cookie 和 Session的区别"></a>7 <code>Cookie</code> 和 <code>Session</code>的区别</h3><ul>
<li><a href="https://blog.csdn.net/axin66ok/article/details/6175522" target="_blank" rel="noopener">https://blog.csdn.net/axin66ok/article/details/6175522</a></li>
<li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e" target="_blank" rel="noopener">https://juejin.im/entry/5766c29d6be3ff006a31b84e</a></li>
</ul>
<blockquote>
<p>session的常见实现要借助cookie来发送sessionID.</p>
</blockquote>
<p>类似这种面试题，实际上都属于“开放性”问题，你扯到哪里都可以。不过如果我是面试官的话，我还是希望对方能做到一点——</p>
<p>不要混淆 session 和 session 实现。</p>
<p>本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。</p>
<p> 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。</p>
<p>而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。</p>
<hr>
<p>1.cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。</p>
<p>2.session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。<br>注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。</p>
<p>3.cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
<p>4.cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。<br>  简单的说，当你登录一个网站的时候，</p>
<p>·         如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造，但是如果你能够获取某个登录用户的 sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性.</p>
<p>·         如果浏览器使用的是cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的  cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy    cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器</p>
<p>5.两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。</p>
<p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p>
<h3 id="8-fail-fast-与-fail-safe-机制有什么区别"><a href="#8-fail-fast-与-fail-safe-机制有什么区别" class="headerlink" title="8 fail-fast 与 fail-safe 机制有什么区别"></a>8 <code>fail-fast</code> 与 <code>fail-safe</code> 机制有什么区别</h3><ul>
<li><a href="https://blog.csdn.net/ch717828/article/details/46892051" target="_blank" rel="noopener">https://blog.csdn.net/ch717828/article/details/46892051</a></li>
<li><a href="https://www.jianshu.com/p/b41a886e0257" target="_blank" rel="noopener">https://www.jianshu.com/p/b41a886e0257</a></li>
</ul>
<h3 id="9-get-和-post请求的区别"><a href="#9-get-和-post请求的区别" class="headerlink" title="9 get 和 post请求的区别"></a>9 <code>get</code> 和 <code>post</code>请求的区别</h3><ul>
<li><a href="https://www.oschina.net/news/77354/http-get-post-different" target="_blank" rel="noopener">https://www.oschina.net/news/77354/http-get-post-different</a></li>
<li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></li>
<li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></li>
</ul>
<h3 id="10-Interface-与-abstract-类的区别"><a href="#10-Interface-与-abstract-类的区别" class="headerlink" title="10 Interface 与 abstract 类的区别"></a>10 <code>Interface</code> 与 <code>abstract</code> 类的区别</h3><ul>
<li><a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">http://www.importnew.com/12399.html</a></li>
<li><a href="https://blog.csdn.net/chenssy/article/details/12858267" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/12858267</a></li>
</ul>
<h3 id="11-IOC的优点是什么"><a href="#11-IOC的优点是什么" class="headerlink" title="11 IOC的优点是什么"></a>11 <code>IOC</code>的优点是什么</h3><ul>
<li><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575</a></li>
<li><a href="http://www.jdon.com/AOPdesign/iocimpls.htm" target="_blank" rel="noopener">http://www.jdon.com/AOPdesign/iocimpls.htm</a></li>
</ul>
<h3 id="12-IO-和-NIO的区别，NIO优点"><a href="#12-IO-和-NIO的区别，NIO优点" class="headerlink" title="12 IO 和 NIO的区别，NIO优点"></a>12 <code>IO</code> 和 <code>NIO</code>的区别，<code>NIO</code>优点</h3><ul>
<li><a href="https://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">https://blog.csdn.net/shimiso/article/details/24990499</a></li>
<li><a href="http://www.importnew.com/1178.html" target="_blank" rel="noopener">http://www.importnew.com/1178.html</a></li>
</ul>
<h3 id="13-Java-8-Java-7-为我们提供了什么新功能"><a href="#13-Java-8-Java-7-为我们提供了什么新功能" class="headerlink" title="13 Java 8 / Java 7 为我们提供了什么新功能"></a>13 <code>Java</code> 8 / <code>Java</code> 7 为我们提供了什么新功能</h3><ul>
<li><a href="https://www.zfl9.com/java-jdk7-jdk8.html" target="_blank" rel="noopener">https://www.zfl9.com/java-jdk7-jdk8.html</a></li>
<li><a href="https://www.oschina.net/translate/everything-about-java-8" target="_blank" rel="noopener">https://www.oschina.net/translate/everything-about-java-8</a></li>
<li><a href="https://blog.csdn.net/u014044812/article/details/78092230" target="_blank" rel="noopener">https://blog.csdn.net/u014044812/article/details/78092230</a></li>
</ul>
<h3 id="14-什么是竞态条件？-举个例子说明。"><a href="#14-什么是竞态条件？-举个例子说明。" class="headerlink" title="14 什么是竞态条件？ 举个例子说明。"></a>14 什么是竞态条件？ 举个例子说明。</h3><p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理，详见<a href="http://javarevisited.blogspot.com/2012/02/what-is-race-condition-in.html" target="_blank" rel="noopener">答案</a>。</p>
<ul>
<li><a href="https://blog.csdn.net/antony9118/article/details/51480978" target="_blank" rel="noopener">https://blog.csdn.net/antony9118/article/details/51480978</a></li>
<li><a href="https://www.jianshu.com/p/30a383844693" target="_blank" rel="noopener">https://www.jianshu.com/p/30a383844693</a></li>
</ul>
<h3 id="15-JRE、JDK、JVM-及-JIT-之间有什么不同"><a href="#15-JRE、JDK、JVM-及-JIT-之间有什么不同" class="headerlink" title="15 JRE、JDK、JVM 及 JIT 之间有什么不同"></a>15 <code>JRE</code>、<code>JDK</code>、<code>JVM</code> 及 <code>JIT</code> 之间有什么不同</h3><h3 id="16-MVC的各个部分都有那些技术来实现-如何实现"><a href="#16-MVC的各个部分都有那些技术来实现-如何实现" class="headerlink" title="16 MVC的各个部分都有那些技术来实现?如何实现?"></a>16 <code>MVC</code>的各个部分都有那些技术来实现?如何实现?</h3><h3 id="17-RPC-通信和-RMI-区别"><a href="#17-RPC-通信和-RMI-区别" class="headerlink" title="17 RPC 通信和 RMI 区别"></a>17 <code>RPC</code> 通信和 <code>RMI</code> 区别</h3><h3 id="18-什么是-Web-Service（Web服务）"><a href="#18-什么是-Web-Service（Web服务）" class="headerlink" title="18 什么是 Web Service（Web服务）"></a>18 什么是 <code>Web</code> <code>Service</code>（<code>Web</code>服务）</h3><h3 id="19-JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><a href="#19-JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。" class="headerlink" title="19 JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。"></a>19 <code>JSWDL</code>开发包的介绍。<code>JAXP</code>、<code>JAXM</code>的解释。<code>SOAP</code>、<code>UDDI</code>,<code>WSDL</code>解释。</h3><h3 id="20-WEB容器主要有哪些功能-并请列出一些常见的WEB容器名字。"><a href="#20-WEB容器主要有哪些功能-并请列出一些常见的WEB容器名字。" class="headerlink" title="20 WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。"></a>20 <code>WEB</code>容器主要有哪些功能? 并请列出一些常见的<code>WEB</code>容器名字。</h3><h3 id="21-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制"><a href="#21-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制" class="headerlink" title="21 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制"></a>21 一个”.<code>java</code>”源文件中是否可以包含多个类（不是内部类）？有什么限制</h3><h3 id="22-简单说说你了解的类加载器。是否实现过类加载器"><a href="#22-简单说说你了解的类加载器。是否实现过类加载器" class="headerlink" title="22 简单说说你了解的类加载器。是否实现过类加载器"></a>22 简单说说你了解的类加载器。是否实现过类加载器</h3><h3 id="23-解释一下什么叫AOP（面向切面编程）"><a href="#23-解释一下什么叫AOP（面向切面编程）" class="headerlink" title="23 解释一下什么叫AOP（面向切面编程）"></a>23 解释一下什么叫<code>AOP</code>（面向切面编程）</h3><h3 id="24-请简述-Servlet-的生命周期及其相关的方法"><a href="#24-请简述-Servlet-的生命周期及其相关的方法" class="headerlink" title="24 请简述 Servlet 的生命周期及其相关的方法"></a>24 请简述 <code>Servlet</code> 的生命周期及其相关的方法</h3><h3 id="25-请简述一下-Ajax-的原理及实现步骤"><a href="#25-请简述一下-Ajax-的原理及实现步骤" class="headerlink" title="25 请简述一下 Ajax 的原理及实现步骤"></a>25 请简述一下 <code>Ajax</code> 的原理及实现步骤</h3><h3 id="26-简单描述Struts的主要功能"><a href="#26-简单描述Struts的主要功能" class="headerlink" title="26 简单描述Struts的主要功能"></a>26 简单描述<code>Struts</code>的主要功能</h3><h3 id="27-什么是-N-层架构"><a href="#27-什么是-N-层架构" class="headerlink" title="27 什么是 N 层架构"></a>27 什么是 <code>N</code> 层架构</h3><h3 id="28-什么是CORBA？用途是什么"><a href="#28-什么是CORBA？用途是什么" class="headerlink" title="28 什么是CORBA？用途是什么"></a>28 什么是<code>CORBA</code>？用途是什么</h3><h3 id="29-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”"><a href="#29-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”" class="headerlink" title="29 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”"></a>29 什么是<code>Java</code>虚拟机？为什么<code>Java</code>被称作是“平台无关的编程语言”</h3><h3 id="30-什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配"><a href="#30-什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配" class="headerlink" title="30 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配"></a>30 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配</h3><h3 id="31-什么是懒加载（Lazy-Loading）"><a href="#31-什么是懒加载（Lazy-Loading）" class="headerlink" title="31 什么是懒加载（Lazy Loading）"></a>31 什么是懒加载（<code>Lazy</code> <code>Loading</code>）</h3><h3 id="32-什么是尾递归，为什么需要尾递归"><a href="#32-什么是尾递归，为什么需要尾递归" class="headerlink" title="32 什么是尾递归，为什么需要尾递归"></a>32 什么是尾递归，为什么需要尾递归</h3><h3 id="33-什么是控制反转（Inversion-of-Control）与依赖注入（Dependency-Injection）"><a href="#33-什么是控制反转（Inversion-of-Control）与依赖注入（Dependency-Injection）" class="headerlink" title="33 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）"></a>33 什么是控制反转（<code>Inversion</code> <code>of</code> <code>Control</code>）与依赖注入（<code>Dependency</code> <code>Injection</code>）</h3><h1 id="—————"><a href="#—————" class="headerlink" title="—————"></a>—————</h1><p>接口</p>
<h3 id="Comparator-与-Comparable-接口是干什么的？列出它们的区别"><a href="#Comparator-与-Comparable-接口是干什么的？列出它们的区别" class="headerlink" title="Comparator 与 Comparable 接口是干什么的？列出它们的区别"></a><code>Comparator</code> 与 <code>Comparable</code> 接口是干什么的？列出它们的区别</h3><p>对象</p>
<p>拷贝(<code>clone</code>)</p>
<h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h3><h3 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h3><h3 id="深拷贝和浅拷贝如何实现激活机制"><a href="#深拷贝和浅拷贝如何实现激活机制" class="headerlink" title="深拷贝和浅拷贝如何实现激活机制"></a>深拷贝和浅拷贝如何实现激活机制</h3><h3 id="写clone-方法时，通常都有一行代码，是什么"><a href="#写clone-方法时，通常都有一行代码，是什么" class="headerlink" title="写clone()方法时，通常都有一行代码，是什么"></a>写<code>clone()</code>方法时，通常都有一行代码，是什么</h3><p>比较</p>
<h3 id="在比较对象时，”-”-运算符和-equals-运算有何区别"><a href="#在比较对象时，”-”-运算符和-equals-运算有何区别" class="headerlink" title="在比较对象时，”==” 运算符和 equals 运算有何区别"></a>在比较对象时，”==” 运算符和 <code>equals</code> 运算有何区别</h3><h3 id="如果要重写一个对象的equals方法，还要考虑什么"><a href="#如果要重写一个对象的equals方法，还要考虑什么" class="headerlink" title="如果要重写一个对象的equals方法，还要考虑什么"></a>如果要重写一个对象的<code>equals</code>方法，还要考虑什么</h3><h3 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对"></a>两个对象值相同(<code>x.equals(y)</code> == <code>true</code>)，但却可有不同的<code>hash</code> <code>code</code>，这句话对不对</h3><p>构造器</p>
<h3 id="构造器链是什么"><a href="#构造器链是什么" class="headerlink" title="构造器链是什么"></a>构造器链是什么</h3><h3 id="创建对象时构造器的调用顺序"><a href="#创建对象时构造器的调用顺序" class="headerlink" title="创建对象时构造器的调用顺序"></a>创建对象时构造器的调用顺序</h3><p>不可变对象</p>
<h3 id="什么是不可变象（immutable-object）"><a href="#什么是不可变象（immutable-object）" class="headerlink" title="什么是不可变象（immutable object）"></a>什么是不可变象（<code>immutable object</code>）</h3><h3 id="为什么-Java-中的-String-是不可变的（Immutable）"><a href="#为什么-Java-中的-String-是不可变的（Immutable）" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）"></a>为什么 <code>Java</code> 中的 <code>String</code> 是不可变的（<code>Immutable</code>）</h3><h3 id="如何构建不可变的类结构？关键点在哪里"><a href="#如何构建不可变的类结构？关键点在哪里" class="headerlink" title="如何构建不可变的类结构？关键点在哪里"></a>如何构建不可变的类结构？关键点在哪里</h3><h3 id="能创建一个包含可变对象的不可变对象吗"><a href="#能创建一个包含可变对象的不可变对象吗" class="headerlink" title="能创建一个包含可变对象的不可变对象吗"></a>能创建一个包含可变对象的不可变对象吗</h3><h3 id="如何对一组对象进行排序"><a href="#如何对一组对象进行排序" class="headerlink" title="如何对一组对象进行排序"></a>如何对一组对象进行排序</h3><p>方法</p>
<h3 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（<code>constructor</code>）是否可被重写（<code>override</code>）</h3><h3 id="方法可以同时即是-static-又是-synchronized-的吗"><a href="#方法可以同时即是-static-又是-synchronized-的吗" class="headerlink" title="方法可以同时即是 static 又是 synchronized 的吗"></a>方法可以同时即是 <code>static</code> 又是 <code>synchronized</code> 的吗</h3><h3 id="abstract-的-method是否可同时是-static，是否可同时是-native，是否可同时是synchronized"><a href="#abstract-的-method是否可同时是-static，是否可同时是-native，是否可同时是synchronized" class="headerlink" title="abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized"></a><code>abstract</code> 的 <code>method</code>是否可同时是 <code>static</code>，是否可同时是 <code>native</code>，是否可同时是<code>synchronized</code></h3><h3 id="Java支持哪种参数传递类型"><a href="#Java支持哪种参数传递类型" class="headerlink" title="Java支持哪种参数传递类型"></a><code>Java</code>支持哪种参数传递类型</h3><h3 id="一个对象被当作参数传递到一个方法，是值传递还是引用传递"><a href="#一个对象被当作参数传递到一个方法，是值传递还是引用传递" class="headerlink" title="一个对象被当作参数传递到一个方法，是值传递还是引用传递"></a>一个对象被当作参数传递到一个方法，是值传递还是引用传递</h3><h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h3><h3 id="我们能否重载main-方法"><a href="#我们能否重载main-方法" class="headerlink" title="我们能否重载main()方法"></a>我们能否重载<code>main()</code>方法</h3><h3 id="如果main方法被声明为private会怎样"><a href="#如果main方法被声明为private会怎样" class="headerlink" title="如果main方法被声明为private会怎样"></a>如果<code>main</code>方法被声明为<code>private</code>会怎样</h3><p><code>GC</code></p>
<p>概念</p>
<h3 id="GC是什么？为什么要有GC"><a href="#GC是什么？为什么要有GC" class="headerlink" title="GC是什么？为什么要有GC"></a><code>GC</code>是什么？为什么要有<code>GC</code></h3><h3 id="什么时候会导致垃圾回收"><a href="#什么时候会导致垃圾回收" class="headerlink" title="什么时候会导致垃圾回收"></a>什么时候会导致垃圾回收</h3><h3 id="GC是怎么样运行的"><a href="#GC是怎么样运行的" class="headerlink" title="GC是怎么样运行的"></a><code>GC</code>是怎么样运行的</h3><h3 id="新老以及永久区是什么"><a href="#新老以及永久区是什么" class="headerlink" title="新老以及永久区是什么"></a>新老以及永久区是什么</h3><h3 id="GC-有几种方式？怎么配置"><a href="#GC-有几种方式？怎么配置" class="headerlink" title="GC 有几种方式？怎么配置"></a><code>GC</code> 有几种方式？怎么配置</h3><h3 id="什么时候一个对象会被GC？-如何判断一个对象是否存活"><a href="#什么时候一个对象会被GC？-如何判断一个对象是否存活" class="headerlink" title="什么时候一个对象会被GC？ 如何判断一个对象是否存活"></a>什么时候一个对象会被<code>GC</code>？ 如何判断一个对象是否存活</h3><h3 id="System-gc-Runtime-gc-会做什么事情？-能保证-GC-执行吗"><a href="#System-gc-Runtime-gc-会做什么事情？-能保证-GC-执行吗" class="headerlink" title="System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗"></a><code>System.gc()</code> <code>Runtime.gc()</code>会做什么事情？ 能保证 <code>GC</code> 执行吗</h3><h3 id="垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"></a>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</h3><h3 id="Minor-GC-、Major-GC、Young-GC-与-Full-GC分别在什么时候发生"><a href="#Minor-GC-、Major-GC、Young-GC-与-Full-GC分别在什么时候发生" class="headerlink" title="Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生"></a><code>Minor</code> <code>GC</code> 、<code>Major</code> <code>GC</code>、<code>Young</code> <code>GC</code> 与 <code>Full</code> <code>GC</code>分别在什么时候发生</h3><h3 id="垃圾回收算法的实现原理"><a href="#垃圾回收算法的实现原理" class="headerlink" title="垃圾回收算法的实现原理"></a>垃圾回收算法的实现原理</h3><h3 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为<code>null</code>，垃圾收集器是否会立即释放对象占用的内存？</h3><h3 id="垃圾回收的最佳做法是什么"><a href="#垃圾回收的最佳做法是什么" class="headerlink" title="垃圾回收的最佳做法是什么"></a>垃圾回收的最佳做法是什么</h3><p><code>GC</code>收集器有哪些</p>
<h3 id="垃圾回收器的基本原理是什么？"><a href="#垃圾回收器的基本原理是什么？" class="headerlink" title="垃圾回收器的基本原理是什么？"></a>垃圾回收器的基本原理是什么？</h3><h3 id="串行-serial-收集器和吞吐量-throughput-收集器的区别是什么"><a href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么" class="headerlink" title="串行(serial)收集器和吞吐量(throughput)收集器的区别是什么"></a>串行(<code>serial</code>)收集器和吞吐量(<code>throughput</code>)收集器的区别是什么</h3><h3 id="Serial-与-Parallel-GC之间的不同之处"><a href="#Serial-与-Parallel-GC之间的不同之处" class="headerlink" title="Serial 与 Parallel GC之间的不同之处"></a><code>Serial</code> 与 <code>Parallel</code> <code>GC</code>之间的不同之处</h3><h3 id="CMS-收集器-与-G1-收集器的特点与区别"><a href="#CMS-收集器-与-G1-收集器的特点与区别" class="headerlink" title="CMS 收集器 与 G1 收集器的特点与区别"></a><code>CMS</code> 收集器 与 <code>G</code>1 收集器的特点与区别</h3><h3 id="CMS垃圾回收器的工作过程"><a href="#CMS垃圾回收器的工作过程" class="headerlink" title="CMS垃圾回收器的工作过程"></a><code>CMS</code>垃圾回收器的工作过程</h3><h3 id="JVM-中一次完整的-GC-流程是怎样的？-对象如何晋升到老年代"><a href="#JVM-中一次完整的-GC-流程是怎样的？-对象如何晋升到老年代" class="headerlink" title="JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代"></a><code>JVM</code> 中一次完整的 <code>GC</code> 流程是怎样的？ 对象如何晋升到老年代</h3><h3 id="吞吐量优先和响应优先的垃圾收集器选择"><a href="#吞吐量优先和响应优先的垃圾收集器选择" class="headerlink" title="吞吐量优先和响应优先的垃圾收集器选择"></a>吞吐量优先和响应优先的垃圾收集器选择</h3><p><code>GC</code>策略</p>
<h3 id="举个实际的场景，选择一个GC策略"><a href="#举个实际的场景，选择一个GC策略" class="headerlink" title="举个实际的场景，选择一个GC策略"></a>举个实际的场景，选择一个<code>GC</code>策略</h3><h3 id="JVM的永久代中会发生垃圾回收吗"><a href="#JVM的永久代中会发生垃圾回收吗" class="headerlink" title="JVM的永久代中会发生垃圾回收吗"></a><code>JVM</code>的永久代中会发生垃圾回收吗</h3><p>收集方法<br>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方<br>如果让你优化收集方法，有什么思路</p>
<p><code>JVM</code></p>
<p>参数</p>
<h3 id="说说你知道的几种主要的jvm-参数"><a href="#说说你知道的几种主要的jvm-参数" class="headerlink" title="说说你知道的几种主要的jvm 参数"></a>说说你知道的几种主要的<code>jvm</code> 参数</h3><h3 id="XX-UseCompressedOops-有什么作用"><a href="#XX-UseCompressedOops-有什么作用" class="headerlink" title="-XX:+UseCompressedOops 有什么作用"></a><code>-XX</code>:+<code>UseCompressedOops</code> 有什么作用</h3><p>类加载器(<code>ClassLoader</code>)</p>
<h3 id="Java-类加载器都有哪些"><a href="#Java-类加载器都有哪些" class="headerlink" title="Java 类加载器都有哪些"></a><code>Java</code> 类加载器都有哪些</h3><h3 id="JVM如何加载字节码文件"><a href="#JVM如何加载字节码文件" class="headerlink" title="JVM如何加载字节码文件"></a><code>JVM</code>如何加载字节码文件</h3><p>内存管理</p>
<h3 id="JVM内存分哪几个区，每个区的作用是什么"><a href="#JVM内存分哪几个区，每个区的作用是什么" class="headerlink" title="JVM内存分哪几个区，每个区的作用是什么"></a><code>JVM</code>内存分哪几个区，每个区的作用是什么</h3><h3 id="一个对象从创建到销毁都是怎么在这些部分里存活和转移的"><a href="#一个对象从创建到销毁都是怎么在这些部分里存活和转移的" class="headerlink" title="一个对象从创建到销毁都是怎么在这些部分里存活和转移的"></a>一个对象从创建到销毁都是怎么在这些部分里存活和转移的</h3><h3 id="解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法"><a href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法" class="headerlink" title="解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法"></a>解释内存中的栈(<code>stack</code>)、堆(<code>heap</code>)和方法区(<code>method</code> <code>area</code>)的用法</h3><h3 id="JVM中哪个参数是用来控制线程的栈堆栈小"><a href="#JVM中哪个参数是用来控制线程的栈堆栈小" class="headerlink" title="JVM中哪个参数是用来控制线程的栈堆栈小"></a><code>JVM</code>中哪个参数是用来控制线程的栈堆栈小</h3><h3 id="简述内存分配与回收策略"><a href="#简述内存分配与回收策略" class="headerlink" title="简述内存分配与回收策略"></a>简述内存分配与回收策略</h3><h3 id="简述重排序，内存屏障，happen-before，主内存，工作内存"><a href="#简述重排序，内存屏障，happen-before，主内存，工作内存" class="headerlink" title="简述重排序，内存屏障，happen-before，主内存，工作内存"></a>简述重排序，内存屏障，<code>happen-before</code>，主内存，工作内存</h3><h3 id="Java中存在内存泄漏问题吗？请举例说明"><a href="#Java中存在内存泄漏问题吗？请举例说明" class="headerlink" title="Java中存在内存泄漏问题吗？请举例说明"></a><code>Java</code>中存在内存泄漏问题吗？请举例说明</h3><h3 id="简述-Java-中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用"><a href="#简述-Java-中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用" class="headerlink" title="简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用"></a>简述 <code>Java</code> 中软引用（<code>SoftReferenc</code>）、弱引用（<code>WeakReference</code>）和虚引用</h3><h3 id="内存映射缓存区是什么"><a href="#内存映射缓存区是什么" class="headerlink" title="内存映射缓存区是什么"></a>内存映射缓存区是什么</h3><ol>
<li><code>jstack</code>，<code>jstat</code>，<code>jmap</code>，<code>jconsole</code>怎么用</li>
<li>32 位 <code>JVM</code> 和 64 位 <code>JVM</code> 的最大堆内存分别是多数？32 位和 64 位的 <code>JVM</code>，<code>int</code> 类型变量的长度是多数？</li>
<li>怎样通过 <code>Java</code> 程序来判断 <code>JVM</code> 是 32 位 还是 64 位</li>
<li><code>JVM</code>自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是<code>JVM</code>自己管理堆</li>
<li>什么情况下会发生栈内存溢出</li>
<li>双亲委派模型是什么</li>
</ol>
<p>面向对象编程（<code>OOP</code>）</p>
<h3 id="解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）"><a href="#解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）" class="headerlink" title="解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）"></a>解释下多态性（<code>polymorphism</code>），封装性（<code>encapsulation</code>），内聚（<code>cohesion</code>）以及耦合（<code>coupling</code>）</h3><h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><h3 id="封装、继承和多态是什么"><a href="#封装、继承和多态是什么" class="headerlink" title="封装、继承和多态是什么"></a>封装、继承和多态是什么</h3><h3 id="对象封装的原则是什么"><a href="#对象封装的原则是什么" class="headerlink" title="对象封装的原则是什么?"></a>对象封装的原则是什么?</h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li>获得一个类的类对象有哪些方式</li>
<li>重载（<code>Overload</code>）和重写（<code>Override</code>）的区别。重载的方法能否根据返回类型进行区分？</li>
<li>说出几条 <code>Java</code> 中方法重载的最佳实践</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>抽象类和接口的区别</li>
<li>抽象类中是否可以有静态的<code>main</code>方法</li>
<li>抽象类是否可实现(<code>implements</code>)接口</li>
<li>抽象类是否可继承具体类(<code>concrete</code> <code>class</code>)</li>
</ol>
<h3 id="匿名类（Anonymous-Inner-Class）"><a href="#匿名类（Anonymous-Inner-Class）" class="headerlink" title="匿名类（Anonymous Inner Class）"></a>匿名类（<code>Anonymous</code> <code>Inner</code> <code>Class</code>）</h3><ol>
<li>匿名内部类是否可以继承其它类？是否可以实现接口</li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol>
<li>内部类分为几种</li>
<li>内部类可以引用它的包含类（外部类）的成员吗</li>
<li>请说一下 <code>Java</code> 中为什么要引入内部类？还有匿名内部类</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li>继承（<code>Inheritance</code>）与聚合（<code>Aggregation</code>）的区别在哪里</li>
<li>继承和组合之间有什么不同</li>
<li>为什么类只能单继承，接口可以多继承</li>
<li>存在两个类，<code>B</code> 继承 <code>A</code>，<code>C</code> 继承 <code>B</code>，能将 <code>B</code> 转换为 <code>C</code> 么？如 <code>C</code> = (<code>C</code>) <code>B</code></li>
<li>如果类 <code>a</code> 继承类 <code>b</code>，实现接口<code>c</code>，而类 <code>b</code> 和接口 <code>c</code> 中定义了同名变量，请问会出现什么问题</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li>接口是什么</li>
<li>接口是否可继承接口</li>
<li>为什么要使用接口而不是直接使用具体类？接口有什么优点</li>
</ol>
<p>泛型</p>
<h3 id="泛型的存在是用来解决什么问题"><a href="#泛型的存在是用来解决什么问题" class="headerlink" title="泛型的存在是用来解决什么问题"></a>泛型的存在是用来解决什么问题</h3><h3 id="泛型的常用特点"><a href="#泛型的常用特点" class="headerlink" title="泛型的常用特点"></a>泛型的常用特点</h3><h3 id="List能否转为List"><a href="#List能否转为List" class="headerlink" title="List能否转为List"></a><code>List</code>能否转为<code>List</code></h3><p>动态代理</p>
<h3 id="描述动态代理的几种实现方式，分别说出相应的优缺点"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点"></a>描述动态代理的几种实现方式，分别说出相应的优缺点</h3><h3 id="什么是-N-1-难题"><a href="#什么是-N-1-难题" class="headerlink" title="什么是 N+1 难题"></a>什么是 <code>N</code>+1 难题</h3><h3 id="什么是-paxos-算法"><a href="#什么是-paxos-算法" class="headerlink" title="什么是 paxos 算法"></a>什么是 <code>paxos</code> 算法</h3><h3 id="什么是-restful，讲讲你理解的-restful"><a href="#什么是-restful，讲讲你理解的-restful" class="headerlink" title="什么是 restful，讲讲你理解的 restful"></a>什么是 <code>restful</code>，讲讲你理解的 <code>restful</code></h3><h3 id="什么是-zab-协议"><a href="#什么是-zab-协议" class="headerlink" title="什么是 zab 协议"></a>什么是 <code>zab</code> 协议</h3><h3 id="什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别"><a href="#什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别" class="headerlink" title="什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别"></a>什么是领域模型(<code>domain</code> <code>model</code>)？贫血模型(<code>anaemic</code> <code>domain</code> <code>model</code>) 和充血模型(<code>rich</code> <code>domain</code> <code>model</code>)有什么区别</h3><h3 id="什么是领域驱动开发（Domain-Driven-Development）"><a href="#什么是领域驱动开发（Domain-Driven-Development）" class="headerlink" title="什么是领域驱动开发（Domain Driven Development）"></a>什么是领域驱动开发（<code>Domain</code> <code>Driven</code> <code>Development</code>）</h3><h3 id="介绍一下了解的-Java-领域的-Web-Service-框架"><a href="#介绍一下了解的-Java-领域的-Web-Service-框架" class="headerlink" title="介绍一下了解的 Java 领域的 Web Service 框架"></a>介绍一下了解的 <code>Java</code> 领域的 <code>Web</code> <code>Service</code> 框架</h3><h3 id="Web-Server、Web-Container-与-Application-Server-的区别是什么"><a href="#Web-Server、Web-Container-与-Application-Server-的区别是什么" class="headerlink" title="Web Server、Web Container 与 Application Server 的区别是什么"></a><code>Web</code> <code>Server</code>、<code>Web</code> <code>Container</code> 与 <code>Application</code> <code>Server</code> 的区别是什么</h3><h3 id="微服务（MicroServices）与巨石型应用（Monolithic-Applications）之间的区别在哪里"><a href="#微服务（MicroServices）与巨石型应用（Monolithic-Applications）之间的区别在哪里" class="headerlink" title="微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里"></a>微服务（<code>MicroServices</code>）与巨石型应用（<code>Monolithic</code> <code>Applications</code>）之间的区别在哪里</h3><h3 id="描述-Cookie-和-Session-的作用，区别和各自的应用范围，Session工作原理"><a href="#描述-Cookie-和-Session-的作用，区别和各自的应用范围，Session工作原理" class="headerlink" title="描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理"></a>描述 <code>Cookie</code> 和 <code>Session</code> 的作用，区别和各自的应用范围，<code>Session</code>工作原理</h3><h3 id="你常用的持续集成（Continuous-Integration）、静态代码分析（Static-Code-Analysis）工具有哪些"><a href="#你常用的持续集成（Continuous-Integration）、静态代码分析（Static-Code-Analysis）工具有哪些" class="headerlink" title="你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些"></a>你常用的持续集成（<code>Continuous</code> <code>Integration</code>）、静态代码分析（<code>Static</code> <code>Code</code> <code>Analysis</code>）工具有哪些</h3><h3 id="简述下数据库正则化（Normalizations）"><a href="#简述下数据库正则化（Normalizations）" class="headerlink" title="简述下数据库正则化（Normalizations）"></a>简述下数据库正则化（<code>Normalizations</code>）</h3><h3 id="KISS-DRY-YAGNI-等原则是什么含义"><a href="#KISS-DRY-YAGNI-等原则是什么含义" class="headerlink" title="KISS,DRY,YAGNI 等原则是什么含义"></a><code>KISS</code>,<code>DRY</code>,<code>YAGNI</code> 等原则是什么含义</h3><h3 id="分布式事务的原理，优缺点，如何使用分布式事务？"><a href="#分布式事务的原理，优缺点，如何使用分布式事务？" class="headerlink" title="分布式事务的原理，优缺点，如何使用分布式事务？"></a>分布式事务的原理，优缺点，如何使用分布式事务？</h3><h3 id="布式集群下如何做到唯一序列号"><a href="#布式集群下如何做到唯一序列号" class="headerlink" title="布式集群下如何做到唯一序列号"></a>布式集群下如何做到唯一序列号</h3><h3 id="是否看过框架的一些代码"><a href="#是否看过框架的一些代码" class="headerlink" title="是否看过框架的一些代码"></a>是否看过框架的一些代码</h3><h3 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些</h3><h3 id="数值提升是什么"><a href="#数值提升是什么" class="headerlink" title="数值提升是什么"></a>数值提升是什么</h3><h3 id="你能解释一下里氏替换原则吗"><a href="#你能解释一下里氏替换原则吗" class="headerlink" title="你能解释一下里氏替换原则吗"></a>你能解释一下里氏替换原则吗</h3><h3 id="你是如何测试一个应用的？知道哪些测试框架"><a href="#你是如何测试一个应用的？知道哪些测试框架" class="headerlink" title="你是如何测试一个应用的？知道哪些测试框架"></a>你是如何测试一个应用的？知道哪些测试框架</h3><h3 id="传输层常见编程协议有哪些？并说出各自的特点"><a href="#传输层常见编程协议有哪些？并说出各自的特点" class="headerlink" title="传输层常见编程协议有哪些？并说出各自的特点"></a>传输层常见编程协议有哪些？并说出各自的特点</h3><p>编程题</p>
<p>计算加班费</p>
<p>加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元/时算。提示：（一个月工作26天，一天正常工作8小时）</p>
<h3 id="计算1000月"><a href="#计算1000月" class="headerlink" title="计算1000月"></a>计算1000月</h3><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/TestNG/" rel="tag"># TestNG</a>
          
            <a href="/tags/Spring-Boot/" rel="tag"># Spring Boot</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/09/Java/Java-8-SecureRandom-生成随机数/" rel="next" title="Java SecureRandom 生成随机数">
                <i class="fa fa-chevron-left"></i> Java SecureRandom 生成随机数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/10/java总结---基本概念/" rel="prev" title="java总结---基本概念">
                java总结---基本概念 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2018/05/10/Interview/java总结---基本概念/" data-title="java总结---基本概念" data-url="http://yoursite.com/2018/05/10/Interview/java总结---基本概念/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Dylan Lang">
            
              <p class="site-author-name" itemprop="name">Dylan Lang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">513</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">120</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-操作系统中-heap-和-stack-的区别"><span class="nav-number">1.</span> <span class="nav-text">1 操作系统中 heap 和 stack 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-什么是基于注解的切面实现"><span class="nav-number">2.</span> <span class="nav-text">2 什么是基于注解的切面实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-什么是-对象-关系-映射集成模块"><span class="nav-number">3.</span> <span class="nav-text">3 什么是 对象/关系 映射集成模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-什么是-Java-的反射机制"><span class="nav-number">4.</span> <span class="nav-text">4 什么是 Java 的反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-什么是-ACID"><span class="nav-number">5.</span> <span class="nav-text">5 什么是 ACID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是ACID特性，数据库如何保证ACID特性的？"><span class="nav-number">6.</span> <span class="nav-text">什么是ACID特性，数据库如何保证ACID特性的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的传播特性？"><span class="nav-number">7.</span> <span class="nav-text">事务的传播特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的隔离级别？"><span class="nav-number">8.</span> <span class="nav-text">事务的隔离级别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-BS与CS的联系与区别"><span class="nav-number">9.</span> <span class="nav-text">6 BS与CS的联系与区别</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#一、C-S与B-S的定义"><span class="nav-number"></span> <span class="nav-text">一、C/S与B/S的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、（C-S）-VS-（B-S-）"><span class="nav-number"></span> <span class="nav-text">二、（C/S）   VS  （B/S ）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的用一张图来表示两者的区别："><span class="nav-number"></span> <span class="nav-text">简单的用一张图来表示两者的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优缺点："><span class="nav-number"></span> <span class="nav-text">优缺点：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-S的优缺点："><span class="nav-number">1.</span> <span class="nav-text">C/S的优缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-S的优缺点："><span class="nav-number">2.</span> <span class="nav-text">B/S的优缺点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、追本溯源"><span class="nav-number"></span> <span class="nav-text">三、追本溯源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Cookie-和-Session的区别"><span class="nav-number">1.</span> <span class="nav-text">7 Cookie 和 Session的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-fail-fast-与-fail-safe-机制有什么区别"><span class="nav-number">2.</span> <span class="nav-text">8 fail-fast 与 fail-safe 机制有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-get-和-post请求的区别"><span class="nav-number">3.</span> <span class="nav-text">9 get 和 post请求的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Interface-与-abstract-类的区别"><span class="nav-number">4.</span> <span class="nav-text">10 Interface 与 abstract 类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-IOC的优点是什么"><span class="nav-number">5.</span> <span class="nav-text">11 IOC的优点是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-IO-和-NIO的区别，NIO优点"><span class="nav-number">6.</span> <span class="nav-text">12 IO 和 NIO的区别，NIO优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Java-8-Java-7-为我们提供了什么新功能"><span class="nav-number">7.</span> <span class="nav-text">13 Java 8 / Java 7 为我们提供了什么新功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-什么是竞态条件？-举个例子说明。"><span class="nav-number">8.</span> <span class="nav-text">14 什么是竞态条件？ 举个例子说明。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-JRE、JDK、JVM-及-JIT-之间有什么不同"><span class="nav-number">9.</span> <span class="nav-text">15 JRE、JDK、JVM 及 JIT 之间有什么不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-MVC的各个部分都有那些技术来实现-如何实现"><span class="nav-number">10.</span> <span class="nav-text">16 MVC的各个部分都有那些技术来实现?如何实现?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-RPC-通信和-RMI-区别"><span class="nav-number">11.</span> <span class="nav-text">17 RPC 通信和 RMI 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-什么是-Web-Service（Web服务）"><span class="nav-number">12.</span> <span class="nav-text">18 什么是 Web Service（Web服务）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI-WSDL解释。"><span class="nav-number">13.</span> <span class="nav-text">19 JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-WEB容器主要有哪些功能-并请列出一些常见的WEB容器名字。"><span class="nav-number">14.</span> <span class="nav-text">20 WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制"><span class="nav-number">15.</span> <span class="nav-text">21 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-简单说说你了解的类加载器。是否实现过类加载器"><span class="nav-number">16.</span> <span class="nav-text">22 简单说说你了解的类加载器。是否实现过类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-解释一下什么叫AOP（面向切面编程）"><span class="nav-number">17.</span> <span class="nav-text">23 解释一下什么叫AOP（面向切面编程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-请简述-Servlet-的生命周期及其相关的方法"><span class="nav-number">18.</span> <span class="nav-text">24 请简述 Servlet 的生命周期及其相关的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-请简述一下-Ajax-的原理及实现步骤"><span class="nav-number">19.</span> <span class="nav-text">25 请简述一下 Ajax 的原理及实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-简单描述Struts的主要功能"><span class="nav-number">20.</span> <span class="nav-text">26 简单描述Struts的主要功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-什么是-N-层架构"><span class="nav-number">21.</span> <span class="nav-text">27 什么是 N 层架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-什么是CORBA？用途是什么"><span class="nav-number">22.</span> <span class="nav-text">28 什么是CORBA？用途是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”"><span class="nav-number">23.</span> <span class="nav-text">29 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配"><span class="nav-number">24.</span> <span class="nav-text">30 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-什么是懒加载（Lazy-Loading）"><span class="nav-number">25.</span> <span class="nav-text">31 什么是懒加载（Lazy Loading）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-什么是尾递归，为什么需要尾递归"><span class="nav-number">26.</span> <span class="nav-text">32 什么是尾递归，为什么需要尾递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-什么是控制反转（Inversion-of-Control）与依赖注入（Dependency-Injection）"><span class="nav-number">27.</span> <span class="nav-text">33 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#—————"><span class="nav-number"></span> <span class="nav-text">—————</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparator-与-Comparable-接口是干什么的？列出它们的区别"><span class="nav-number">1.</span> <span class="nav-text">Comparator 与 Comparable 接口是干什么的？列出它们的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现对象克隆"><span class="nav-number">2.</span> <span class="nav-text">如何实现对象克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝和浅拷贝区别"><span class="nav-number">3.</span> <span class="nav-text">深拷贝和浅拷贝区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝和浅拷贝如何实现激活机制"><span class="nav-number">4.</span> <span class="nav-text">深拷贝和浅拷贝如何实现激活机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写clone-方法时，通常都有一行代码，是什么"><span class="nav-number">5.</span> <span class="nav-text">写clone()方法时，通常都有一行代码，是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在比较对象时，”-”-运算符和-equals-运算有何区别"><span class="nav-number">6.</span> <span class="nav-text">在比较对象时，”==” 运算符和 equals 运算有何区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果要重写一个对象的equals方法，还要考虑什么"><span class="nav-number">7.</span> <span class="nav-text">如果要重写一个对象的equals方法，还要考虑什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对"><span class="nav-number">8.</span> <span class="nav-text">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器链是什么"><span class="nav-number">9.</span> <span class="nav-text">构造器链是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象时构造器的调用顺序"><span class="nav-number">10.</span> <span class="nav-text">创建对象时构造器的调用顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是不可变象（immutable-object）"><span class="nav-number">11.</span> <span class="nav-text">什么是不可变象（immutable object）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Java-中的-String-是不可变的（Immutable）"><span class="nav-number">12.</span> <span class="nav-text">为什么 Java 中的 String 是不可变的（Immutable）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何构建不可变的类结构？关键点在哪里"><span class="nav-number">13.</span> <span class="nav-text">如何构建不可变的类结构？关键点在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#能创建一个包含可变对象的不可变对象吗"><span class="nav-number">14.</span> <span class="nav-text">能创建一个包含可变对象的不可变对象吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何对一组对象进行排序"><span class="nav-number">15.</span> <span class="nav-text">如何对一组对象进行排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器（constructor）是否可被重写（override）"><span class="nav-number">16.</span> <span class="nav-text">构造器（constructor）是否可被重写（override）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法可以同时即是-static-又是-synchronized-的吗"><span class="nav-number">17.</span> <span class="nav-text">方法可以同时即是 static 又是 synchronized 的吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract-的-method是否可同时是-static，是否可同时是-native，是否可同时是synchronized"><span class="nav-number">18.</span> <span class="nav-text">abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java支持哪种参数传递类型"><span class="nav-number">19.</span> <span class="nav-text">Java支持哪种参数传递类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个对象被当作参数传递到一个方法，是值传递还是引用传递"><span class="nav-number">20.</span> <span class="nav-text">一个对象被当作参数传递到一个方法，是值传递还是引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><span class="nav-number">21.</span> <span class="nav-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们能否重载main-方法"><span class="nav-number">22.</span> <span class="nav-text">我们能否重载main()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果main方法被声明为private会怎样"><span class="nav-number">23.</span> <span class="nav-text">如果main方法被声明为private会怎样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC是什么？为什么要有GC"><span class="nav-number">24.</span> <span class="nav-text">GC是什么？为什么要有GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候会导致垃圾回收"><span class="nav-number">25.</span> <span class="nav-text">什么时候会导致垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC是怎么样运行的"><span class="nav-number">26.</span> <span class="nav-text">GC是怎么样运行的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新老以及永久区是什么"><span class="nav-number">27.</span> <span class="nav-text">新老以及永久区是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-有几种方式？怎么配置"><span class="nav-number">28.</span> <span class="nav-text">GC 有几种方式？怎么配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候一个对象会被GC？-如何判断一个对象是否存活"><span class="nav-number">29.</span> <span class="nav-text">什么时候一个对象会被GC？ 如何判断一个对象是否存活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc-Runtime-gc-会做什么事情？-能保证-GC-执行吗"><span class="nav-number">30.</span> <span class="nav-text">System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"><span class="nav-number">31.</span> <span class="nav-text">垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC-、Major-GC、Young-GC-与-Full-GC分别在什么时候发生"><span class="nav-number">32.</span> <span class="nav-text">Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法的实现原理"><span class="nav-number">33.</span> <span class="nav-text">垃圾回收算法的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><span class="nav-number">34.</span> <span class="nav-text">如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的最佳做法是什么"><span class="nav-number">35.</span> <span class="nav-text">垃圾回收的最佳做法是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器的基本原理是什么？"><span class="nav-number">36.</span> <span class="nav-text">垃圾回收器的基本原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行-serial-收集器和吞吐量-throughput-收集器的区别是什么"><span class="nav-number">37.</span> <span class="nav-text">串行(serial)收集器和吞吐量(throughput)收集器的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-与-Parallel-GC之间的不同之处"><span class="nav-number">38.</span> <span class="nav-text">Serial 与 Parallel GC之间的不同之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS-收集器-与-G1-收集器的特点与区别"><span class="nav-number">39.</span> <span class="nav-text">CMS 收集器 与 G1 收集器的特点与区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS垃圾回收器的工作过程"><span class="nav-number">40.</span> <span class="nav-text">CMS垃圾回收器的工作过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-中一次完整的-GC-流程是怎样的？-对象如何晋升到老年代"><span class="nav-number">41.</span> <span class="nav-text">JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吞吐量优先和响应优先的垃圾收集器选择"><span class="nav-number">42.</span> <span class="nav-text">吞吐量优先和响应优先的垃圾收集器选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举个实际的场景，选择一个GC策略"><span class="nav-number">43.</span> <span class="nav-text">举个实际的场景，选择一个GC策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM的永久代中会发生垃圾回收吗"><span class="nav-number">44.</span> <span class="nav-text">JVM的永久代中会发生垃圾回收吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说你知道的几种主要的jvm-参数"><span class="nav-number">45.</span> <span class="nav-text">说说你知道的几种主要的jvm 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XX-UseCompressedOops-有什么作用"><span class="nav-number">46.</span> <span class="nav-text">-XX:+UseCompressedOops 有什么作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-类加载器都有哪些"><span class="nav-number">47.</span> <span class="nav-text">Java 类加载器都有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM如何加载字节码文件"><span class="nav-number">48.</span> <span class="nav-text">JVM如何加载字节码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM内存分哪几个区，每个区的作用是什么"><span class="nav-number">49.</span> <span class="nav-text">JVM内存分哪几个区，每个区的作用是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个对象从创建到销毁都是怎么在这些部分里存活和转移的"><span class="nav-number">50.</span> <span class="nav-text">一个对象从创建到销毁都是怎么在这些部分里存活和转移的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法"><span class="nav-number">51.</span> <span class="nav-text">解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM中哪个参数是用来控制线程的栈堆栈小"><span class="nav-number">52.</span> <span class="nav-text">JVM中哪个参数是用来控制线程的栈堆栈小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述内存分配与回收策略"><span class="nav-number">53.</span> <span class="nav-text">简述内存分配与回收策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述重排序，内存屏障，happen-before，主内存，工作内存"><span class="nav-number">54.</span> <span class="nav-text">简述重排序，内存屏障，happen-before，主内存，工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中存在内存泄漏问题吗？请举例说明"><span class="nav-number">55.</span> <span class="nav-text">Java中存在内存泄漏问题吗？请举例说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述-Java-中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用"><span class="nav-number">56.</span> <span class="nav-text">简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射缓存区是什么"><span class="nav-number">57.</span> <span class="nav-text">内存映射缓存区是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）"><span class="nav-number">58.</span> <span class="nav-text">解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态的实现原理"><span class="nav-number">59.</span> <span class="nav-text">多态的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装、继承和多态是什么"><span class="nav-number">60.</span> <span class="nav-text">封装、继承和多态是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象封装的原则是什么"><span class="nav-number">61.</span> <span class="nav-text">对象封装的原则是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">62.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">63.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名类（Anonymous-Inner-Class）"><span class="nav-number">64.</span> <span class="nav-text">匿名类（Anonymous Inner Class）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">65.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">66.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">67.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型的存在是用来解决什么问题"><span class="nav-number">68.</span> <span class="nav-text">泛型的存在是用来解决什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型的常用特点"><span class="nav-number">69.</span> <span class="nav-text">泛型的常用特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List能否转为List"><span class="nav-number">70.</span> <span class="nav-text">List能否转为List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述动态代理的几种实现方式，分别说出相应的优缺点"><span class="nav-number">71.</span> <span class="nav-text">描述动态代理的几种实现方式，分别说出相应的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-N-1-难题"><span class="nav-number">72.</span> <span class="nav-text">什么是 N+1 难题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-paxos-算法"><span class="nav-number">73.</span> <span class="nav-text">什么是 paxos 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-restful，讲讲你理解的-restful"><span class="nav-number">74.</span> <span class="nav-text">什么是 restful，讲讲你理解的 restful</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-zab-协议"><span class="nav-number">75.</span> <span class="nav-text">什么是 zab 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是领域模型-domain-model-？贫血模型-anaemic-domain-model-和充血模型-rich-domain-model-有什么区别"><span class="nav-number">76.</span> <span class="nav-text">什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是领域驱动开发（Domain-Driven-Development）"><span class="nav-number">77.</span> <span class="nav-text">什么是领域驱动开发（Domain Driven Development）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍一下了解的-Java-领域的-Web-Service-框架"><span class="nav-number">78.</span> <span class="nav-text">介绍一下了解的 Java 领域的 Web Service 框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-Server、Web-Container-与-Application-Server-的区别是什么"><span class="nav-number">79.</span> <span class="nav-text">Web Server、Web Container 与 Application Server 的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#微服务（MicroServices）与巨石型应用（Monolithic-Applications）之间的区别在哪里"><span class="nav-number">80.</span> <span class="nav-text">微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述-Cookie-和-Session-的作用，区别和各自的应用范围，Session工作原理"><span class="nav-number">81.</span> <span class="nav-text">描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你常用的持续集成（Continuous-Integration）、静态代码分析（Static-Code-Analysis）工具有哪些"><span class="nav-number">82.</span> <span class="nav-text">你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述下数据库正则化（Normalizations）"><span class="nav-number">83.</span> <span class="nav-text">简述下数据库正则化（Normalizations）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KISS-DRY-YAGNI-等原则是什么含义"><span class="nav-number">84.</span> <span class="nav-text">KISS,DRY,YAGNI 等原则是什么含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式事务的原理，优缺点，如何使用分布式事务？"><span class="nav-number">85.</span> <span class="nav-text">分布式事务的原理，优缺点，如何使用分布式事务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布式集群下如何做到唯一序列号"><span class="nav-number">86.</span> <span class="nav-text">布式集群下如何做到唯一序列号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否看过框架的一些代码"><span class="nav-number">87.</span> <span class="nav-text">是否看过框架的一些代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些"><span class="nav-number">88.</span> <span class="nav-text">持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值提升是什么"><span class="nav-number">89.</span> <span class="nav-text">数值提升是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你能解释一下里氏替换原则吗"><span class="nav-number">90.</span> <span class="nav-text">你能解释一下里氏替换原则吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你是如何测试一个应用的？知道哪些测试框架"><span class="nav-number">91.</span> <span class="nav-text">你是如何测试一个应用的？知道哪些测试框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层常见编程协议有哪些？并说出各自的特点"><span class="nav-number">92.</span> <span class="nav-text">传输层常见编程协议有哪些？并说出各自的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算1000月"><span class="nav-number">93.</span> <span class="nav-text">计算1000月</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文献"><span class="nav-number">94.</span> <span class="nav-text">参考文献</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Lang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
