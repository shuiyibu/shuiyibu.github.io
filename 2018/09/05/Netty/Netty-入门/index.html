<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="redis,">





  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">






<meta name="description" content="转自http://www.tianshouzhi.com/api/tutorials/netty/221 0 Unix五种IO模型与Java IO模型演进  IO 是主存和外部设备 ( 硬盘、终端和网络等 ) 拷贝数据的过程。 IO 是操作系统的底层功能实现，底层通过 I/O 指令进行完成。在本教程中，我们所说的IO指的都是网络IO。  《UNIX网络编程：卷一》第六章——I/O复用。书中向我们">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 入门">
<meta property="og:url" content="http://yoursite.com/2018/09/05/Netty/Netty-入门/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转自http://www.tianshouzhi.com/api/tutorials/netty/221 0 Unix五种IO模型与Java IO模型演进  IO 是主存和外部设备 ( 硬盘、终端和网络等 ) 拷贝数据的过程。 IO 是操作系统的底层功能实现，底层通过 I/O 指令进行完成。在本教程中，我们所说的IO指的都是网络IO。  《UNIX网络编程：卷一》第六章——I/O复用。书中向我们">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366231306044257.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366318807076211.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366389700024047.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366448898081321.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366503112041652.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366526919011627.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366681774007008.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366919025047427.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483367214824009438.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483367362118028511.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455604027086782.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455680392007615.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455754587098937.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455856965083181.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455928294090896.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455982036044445.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456005263067812.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456072582059808.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456117198030323.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456194499026001.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20180424/1524549616871070892.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20180424/1524549629737056549.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170104/1483540103154037014.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258359783066030.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258459031010273.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258662091064940.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486259691612064981.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486259922514007599.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260132790084013.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260350101064116.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260368843052054.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486129913903078046.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486129979839014747.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130067321058461.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130113709043975.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130350803068991.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130401975018511.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130497191094359.png">
<meta property="og:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130747296085576.png">
<meta property="og:updated_time" content="2018-09-08T11:23:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 入门">
<meta name="twitter:description" content="转自http://www.tianshouzhi.com/api/tutorials/netty/221 0 Unix五种IO模型与Java IO模型演进  IO 是主存和外部设备 ( 硬盘、终端和网络等 ) 拷贝数据的过程。 IO 是操作系统的底层功能实现，底层通过 I/O 指令进行完成。在本教程中，我们所说的IO指的都是网络IO。  《UNIX网络编程：卷一》第六章——I/O复用。书中向我们">
<meta name="twitter:image" content="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366231306044257.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/05/Netty/Netty-入门/">





  <title>Netty 入门 | Hexo</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4d5b541690a836307558f5f13157a238";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/Netty/Netty-入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dylan Lang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Netty 入门</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T14:57:43+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/05/Netty/Netty-入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/05/Netty/Netty-入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<p>转自<a href="http://www.tianshouzhi.com/api/tutorials/netty/221" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/netty/221</a></p>
<h2 id="0-Unix五种IO模型与Java-IO模型演进"><a href="#0-Unix五种IO模型与Java-IO模型演进" class="headerlink" title="0 Unix五种IO模型与Java IO模型演进"></a>0 Unix五种IO模型与Java IO模型演进</h2><p>  IO 是主存和外部设备 ( 硬盘、终端和网络等 ) 拷贝数据的过程。 IO 是操作系统的底层功能实现，底层通过 I/O 指令进行完成。在本教程中，我们所说的IO指的都是<strong>网络IO</strong>。</p>
<p> 《UNIX网络编程：卷一》第六章——I/O复用。书中向我们提及了5种类UNIX下可用的I/O模型：</p>
<p>1、阻塞式I/O：blocking IO</p>
<p>2、非阻塞式I/O： nonblocking IO</p>
<p>3、I/O复用（select，poll，epoll…）：IO multiplexing</p>
<p>4、信号驱动式I/O（SIGIO）：signal driven IO</p>
<p>5、异步I/O（POSIX的aio_系列函数）：asynchronous IO</p>
<p>对于这五种IO模型，Java并不是一开始就都全部支持，而是有一个逐步演进的过程：</p>
<pre><code>在JDK1.4之前，Java的IO模型只支持阻塞式IO(Blocking IO)，简称为BIO 

在JDK1.4时，支持了I/O多路复用模型，相对于之前的IO模型，这是一个新的模型，所以称之为NIO（New IO），有新就有旧，所以有时也把BIO称之为OIO(old IO)，其实都是一个意思。到现在为止，JDK1.8都已经出来了，JDK1.4时引入的nio包，也没有什么新鲜的了，所以更多的人愿意把NIO理解为`Non-Blocking IO`，即非阻塞IO。

在JDK1.7时，对NIO包进行了升级，支持了异步I/O(Asynchronous IO)，简称为`AIO`，因为是对`nio`包的升级，所有有时又称之为NIO2.0。
</code></pre><p>理解了Java IO模型演进与Unix五种IO模型之间的关系之后，我们对这五种模型进行详细的介绍。</p>
<p>在这里，我们以一个网络IO来举例：</p>
<p>对于一个network IO (以read举例)，它会涉及到两个系统对象，==一个是调用这个IO的进程，另一个就是系统内核(kernel)==。当一个read操作发生时，它会经历两个阶段：</p>
<p><strong>阶段1：</strong>等待数据准备 (Waiting for the data to be ready)</p>
<p><strong>阶段2：</strong> 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
<p>如果下图所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366231306044257.png" alt="Image.png"></p>
<p>图中明显忽略了很多细节，仅显示了涉及到的基本步骤 ，注意图中用户空间和内核空间的概念。</p>
<p> <strong>用户空间</strong>是常规进程所在区域。 JVM 就是常规进程，驻守于用户空间。用户空间是非特权区域：比如，在该区域执行的代码就不能直接访问硬件设备。</p>
<p> <strong>内核空间</strong>是操作系统所在区域。内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态，等等。最重要的是，所有 I/O 都直接（如这里所述）或间接通过内核空间。</p>
<p> 当进程请求 I/O 操作的时候，它执行一个系统调用将控制权移交给内核。C/C++程序员所熟知的底层函数 open( )、 read( )、 write( )和 close( )要做的无非就是建立和执行适当的系统调用。当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据传送到用户空间内的指定缓冲区。内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则进程被挂起，内核着手把数据读进内存。</p>
<p> 了解了这两个阶段的作用之后，我们接下来就可以深入讲解五种IO模型了，他们的区别就是在两个阶段上上有着不同的逻辑。</p>
<h3 id="1、Blocking-IO"><a href="#1、Blocking-IO" class="headerlink" title="1、Blocking IO"></a><strong>1、Blocking IO</strong></h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p>第一步通常涉及等待数据从网络中到达。当所有等待数据到达时，它被复制到内核中的某个缓冲区。</p>
<p>第二步就是把数据从内核缓冲区复制到应用程序缓冲区。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366318807076211.png" alt="Image.png"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除 block的状态，重新运行起来。</p>
<p><strong>所以，blocking IO的特点就是在IO执行的==两个阶段==都被block了。</strong></p>
<blockquote>
<p>这个会是回调吗？?????????</p>
</blockquote>
<h3 id="2、非阻塞式I-O"><a href="#2、非阻塞式I-O" class="headerlink" title="2、非阻塞式I/O"></a><strong>2、非阻塞式I/O</strong></h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366389700024047.png" alt="Image.png"></p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>所以，用户进程第一个阶段不是阻塞的,需要不断的主动询问kernel数据好了没有；第二个阶段依然总是阻塞的。</strong></p>
<h3 id="3-I-O多路复用"><a href="#3-I-O多路复用" class="headerlink" title="3 I/O多路复用"></a><strong>3 I/O多路复用</strong></h3><p> IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为<code>event driven IO</code>。我们都知道，==select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO==。</p>
<p> IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。</p>
<p>它的基本原理就是select /epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366448898081321.png" alt="Image.png"></p>
<p>当用户进程调用了<code>select</code>，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个 socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p> 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，==如果处理的连接数不是很高的话，使用 select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大==。</p>
<p>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被 block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="4-信号驱动式I-O"><a href="#4-信号驱动式I-O" class="headerlink" title="4 信号驱动式I/O"></a><strong>4 信号驱动式I/O</strong></h3><p>用的很少，就不做讲解了。直接上图</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366503112041652.png" alt="Image.png"></p>
<h3 id="5-异步I-O"><a href="#5-异步I-O" class="headerlink" title="5 异步I/O"></a><strong>5 异步I/O</strong></h3><p>这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。如图：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366526919011627.png" alt="Image.png"></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都 完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 在这整个过程中，进程完全没有被block。</p>
<p><strong>总结：</strong></p>
<p>其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。 </p>
<p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从 kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<h2 id="1-BIO编程与其局限性"><a href="#1-BIO编程与其局限性" class="headerlink" title="1 BIO编程与其局限性"></a>1 BIO编程与其局限性</h2><p>所谓BIO编程，就是使用JDK1.4之前的api进行编程，在这里我们以ServerSocket和Socket为例进行讲解，编写一个时间服务的C/S架构应用。</p>
<p>client可以发送请求指令”GET CURRENT TIME”给server端，每隔5秒钟发送一次，每次server端都返回当前时间。考虑到TCP编程中，不可避免的要处理粘包、解包的处理，这里为了简化，server在解包的时候，每次读取一行，认为一行就是一个请求。</p>
<p> 考虑到可能会有多个client同时请求server，我们针对每个client创建一个线程来进行处理，因此架构如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366681774007008.png" alt="Image.png"></p>
<p>这实际上就是最简化的<code>reactor线程模型</code>，实际上netty使用也是这种模型，只不过稍微复杂了一点点。Accpetor  thread只负责与client建立连接，worker thread用于处理每个thread真正要执行的操作。</p>
<p>下面是代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深圳金融电子结算中心</span></span><br><span class="line"><span class="comment"> * Copyright (c) 1995-2018 All Rights Reserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dylan Lang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Id: TimeServer.java, v 0.1 Sep 5, 2018 3:56:12 PM Dylan Lang Exp $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">"TimeServer started on port 8080..."</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket client = server.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeServerHandler(client)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket clientProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServerHandler</span><span class="params">(Socket clientProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.clientProxy = clientProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientProxy.getInputStream()));</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(clientProxy.getOutputStream());</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String request = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"GET CURRENT TIME"</span>.equals(request)) &#123;</span><br><span class="line">                    writer.println(<span class="string">"BAD_REQUEST"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    writer.println(Calendar.getInstance().getTime().toLocaleString());</span><br><span class="line">                &#125;</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">                reader.close();</span><br><span class="line">                clientProxy.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个案例中：</p>
<p>  我们把主(main)线程作为accpetor thread，因为我们main线程中执行了ServerSocket的accept方法，事实上，你可以认为，在哪个线程中执行了ServerSocket.accpet()，哪个线程就是accpetor thread</p>
<p>  针对每个client，我们都创建了一个新的Thread来处理这个client的请求，直到连接关闭，我们通过new 方法创建的线程就是worker Thread</p>
<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        Socket client = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(client.getOutputStream());</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                writer.print(<span class="string">"GET CURRENT TIME"</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                String response = reader.readLine();</span><br><span class="line">                System.out.println(<span class="string">"Current Time"</span> + response);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">                reader.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先运行服务端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeServer Started on 8080...</span><br></pre></td></tr></table></figure>
<p>接着启动客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Current Time:2016-12-17 22:24:51</span><br><span class="line"></span><br><span class="line">Current Time:2016-12-17 22:24:56</span><br><span class="line"></span><br><span class="line">Current Time:2016-12-17 22:25:01</span><br><span class="line"></span><br><span class="line">Current Time:2016-12-17 22:25:06</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，我们的程序已经正常工作。</p>
<h3 id="BIO编程的局限性"><a href="#BIO编程的局限性" class="headerlink" title="BIO编程的局限性"></a><strong>BIO编程的局限性</strong></h3><p>下面我们来分析上述代码的局限性，主要是server端。我们要将server端的终极目标：<strong>“server端应该使用尽可能少的线程，来处理尽可能多的client请求”</strong>牢记心中，这是server端优化的一个关键。</p>
<p> 上述代码中，针对每个client，都创建一个对应的线程来处理，如果client非常多，那么server端就要创建无数个线程来与之对应。而线程数量越多，线程上下文切换(context switch)造成的资源损耗就越大，因此我们需要使用尽可能少的线程。</p>
<p>  那么为什么要针对每个client都建立一个线程呢？因为BIO编程使用的是我们之前讲解的阻塞式(Blocking)I/O模型，在读取数据的时候，如果没有数据就一直等待。为了及时的响应每个client的请求，我们必须为每个client创建一个线程。例如，假设我们使用一个线程服务两个client：client A、client B，可能clientA当前没有发送请求，clientB发送了请求。如果此时线程正在读取clientA的数据，因为没有，导致线程一直处于阻塞状态，而clientB虽然有请求，但是线程因为被阻塞，也无法继续执行下去。</p>
<p>  因此BIO，无法满足server的终极目标，<strong>“server端应该使用尽可能少的线程，来处理尽可能多的client请求”</strong>。</p>
<p>   可能会有人想到用线程池的方式优化，此时架构如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483366919025047427.png" alt="Image.png"></p>
<p>server不再针对每个client都创建一个新的线程，而是维护一个线程池，每次有client连接时，将其构造成一个task，交给ThreadPool处理。这样就可以最大化的复用线程。</p>
<p><strong>想法是好的，现实很残酷，因为在阻塞式I/O模型下，使用线程池本身就是一个伪命题。</strong>  </p>
<p>线程池的工作原理是，内部维护了一系列线程，接受到一个任务时，会找出一个当前空闲的线程来处理这个任务，这个任务处理完成之后，再将这个线程返回到池子中。</p>
<p>而在阻塞式IO中，因为需要不断的检查一个client是否有新的请求，也就是调用其read方法，而这个方法是阻塞的，意味着，一旦调用了这个方法，如果没有读取到数据，那么这个线程就会一直block在那里，一直等到有数据，等到有了数据的时候，处理完成，立即由需要进行下一次判断，这个client有没有再次发送请求，如果没有，又block住了，因此可以认为，线程基本上是用一个少一个，因为对于一个client如果没有断开连接，就相当于这个任务没有处理完，任务没有处理完，线程永远不会返回到池子中，直到这个client断开连接。</p>
<p> <strong>在BIO中，用了线程池，意味着线程池中维护的线程数，也就是server端支持最多有多少个client来连接。</strong></p>
<p>这里不得不提到&lt;&lt;netty权威指南&gt;&gt;的作者李林峰对读者的误导了，他的书中，2.2节，所谓的伪异步IO编程，用的就是上面这个方法。当然他对读者的误导，不止这一个地方，他在infoq发表的一篇文章，提到netty4内存池方面的问题，也是漏洞百出，我们将会之后分析到内存池的时候进行讲解。</p>
<p>现在我们来分析，BIO不支持server端的终极目标：<strong>“server端应该使用尽可能少的线程，来处理尽可能多的client请求”</strong> 的原因：</p>
<p>回顾我们在上一节讲解的UNIX五种IO模型中，读取数据都必须要经过的两个阶段：</p>
<p>阶段1、等待数据准备</p>
<p>阶段2、将准备好的数据从内核空间拷贝到用户空间</p>
<p>对于阶段1，其等待时间可能是无限长的，因为一个与server已经建立连接的client，可能很长时间内都没有发送新的请求</p>
<p>对于阶段2，只是将数据从内核空间拷贝到用户空间，这个时间实际上是很短的</p>
<p>由于在Blocking IO模型中，进程是不区分这两个阶段的，把其当做一个整体来运行（这对应于Socket的<code>getInputStream</code>方法返回的<code>InputStream</code> 对象的read方法，这个方法不区分这两个阶段）。因此在没有数据准备好的情况下，是一直被阻塞的。而我们前面的代码， worker thread在不知道client有没有新的数据的情况下， 直接尝试去读取数据，因此线程被block住。</p>
<p>如果我们有一种机制，可以对这两个阶段进行区分。</p>
<p>那么我们就可以用一个专门的线程去负责第一阶段：这个线程去检查有哪些client准备好了数据，然后将这些client过滤出来，交给worker线程去处理</p>
<p>而worker线程只负责第二阶段：因为第一个阶段已经保证了当前处理的client肯定是有数据的，这样worker线程在读取的时候，阻塞时间是很短的，而不必经历第一阶段那样长时间的等待。</p>
<p>这实际上就是我们之前提到的UNIX 五种IO模型中的多路复用模型，我们将在下一节中看到java的nio包是如何对此进行支持的。 </p>
<h2 id="2-NIO-Buffer"><a href="#2-NIO-Buffer" class="headerlink" title="2 NIO Buffer"></a>2 NIO Buffer</h2><p>我们以 Buffer 类开始我们对 <code>java.nio</code> 软件包的浏览历程。这些类是 <code>java.nio</code> 的构造基础。在本章中，我们将深入研究缓冲区， 了解各种不同的类型，并学会怎样使用。</p>
<p><strong>==一个Buffer对象是固定数量的数据的容器==</strong>。其作用是一个存储器，或者分段运输区，在这里数据可被存储并在之后用于检索。缓冲区如我们在第一章所讨论的那样被写满和释放。对于每个非布尔原始数据类型都有一个缓冲区类。<strong>==尽管缓冲区作用于它们存储的原始数据类型，但缓冲区十分倾向于处理字节==</strong>。</p>
<p>缓冲区的工作与通道紧密联系。通道是 I/O 传输发生时通过的入口，而缓冲区是这些数据传输的来源或目标。对于离开缓冲区的传输，您想传递出去的数据被置于一个缓冲区，被传送到通道。对于传回缓冲区的传输，一个通道将数据放置在您所提供的缓冲区中。这种在<code>协同对象</code>（通常是您所写的对象以及一到多个 Channel 对象）之间进行的缓冲区数据传递是高效数据处理的关键。通道将在第三章被详细涉及。</p>
<p>下图是 Buffer 的类层次图。在顶部是通用 Buffer 类。 Buffer 定义所有缓冲区类型共有的操作，无论是它们所包含的数据类型还是可能具有的特定行为。这一共同点将会成为我们的出发点。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483367214824009438.png" alt="Image.png"></p>
<p>关于这么多Buffer类型，我们只关注ByteBuffer，因为在NIO网络编程中，通道直接从ByteBuffer中读取数据。不过好处在于，不同的Buffer实现类，api都是相似的，当我们学会了ByteBuffer，其他的类型的Buffer自然而言也就会了。</p>
<h3 id="1-缓冲区基础"><a href="#1-缓冲区基础" class="headerlink" title="1 缓冲区基础"></a>1 缓冲区基础</h3><p><strong>概念上，缓冲区是包在一个对象内的基本数据元素数组</strong>。 ==Buffer 类相比一个简单数组的优点 是它将关于数据的数据内容和信息包含在一个单一的对象中==。 Buffer 类以及它专有的子类定义了 一个用于处理数据缓冲区的 API。</p>
<p>Buffer类定义了所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>容量（ Capacity）</strong></p>
<p>缓冲区能够容纳的数据元素的最大数量，可以理解为数组的长度。 这一容量在缓冲区创建时被设定，并且永远不能被改变。</p>
<p><strong>上界（ Limit）</strong></p>
<p>缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。</p>
<p><strong>位置（ Position）</strong></p>
<p>下一个要被读或写的元素的索引。Buffer类提供了get( )和 put( )函数 来读取或存入数据，position位置会自动进行相应的更新。</p>
<p><strong>标记（ Mark）</strong></p>
<p>一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的(undefined)。</p>
<p>这四个属性之间总是遵循以下关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</span><br></pre></td></tr></table></figure>
<p>让我们来看看这些属性在实际应用中的一些例子。下图展示了一个新创建的容量为 10 的 ByteBuffer 逻辑视图。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170102/1483367362118028511.png" alt="Image.png"></p>
<p>position被设为 0，而且capacity和limit被设为 10。mark最初未定义。capacity是固定的，但另外的三个属性可以在使用缓冲区时改变。 </p>
<h3 id="2-缓冲区API"><a href="#2-缓冲区API" class="headerlink" title="2 缓冲区API"></a>2 缓冲区API</h3><p>Buffer类定义了所有缓冲区实现类需要实现的方法，以下列出的只是这些方法的签名，不包含实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JDK1.4时，引入的api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">( )</span><span class="comment">//返回此缓冲区的容量</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">( )</span><span class="comment">//返回此缓冲区的位置</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span> <span class="params">(<span class="keyword">int</span> newPositio)</span><span class="comment">//设置此缓冲区的位置</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">( )</span><span class="comment">//返回此缓冲区的限制</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span> <span class="params">(<span class="keyword">int</span> newLimit)</span><span class="comment">//设置此缓冲区的限制</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">( )</span><span class="comment">//在此缓冲区的位置设置标记</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">( )</span><span class="comment">//将此缓冲区的位置重置为以前标记的位置</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">( )</span><span class="comment">//清除此缓冲区</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">( )</span><span class="comment">//反转此缓冲区</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">( )</span><span class="comment">//重绕此缓冲区</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">( )</span><span class="comment">//返回当前位置与限制之间的元素数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">( )</span><span class="comment">//告知在当前位置和限制之间是否有元素</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">( )</span></span>;<span class="comment">//告知此缓冲区是否为只读缓冲区</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//JDK1.6时引入的api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>;<span class="comment">//告知此缓冲区是否具有可访问的底层实现数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">array</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的底层实现数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span>;<span class="comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;<span class="comment">//告知此缓冲区是否为直接缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 聪明的读者会注意到：</p>
<p> 1、Buffer类的七种基本数据类型的缓冲区实现也都是抽象的，这些类没有一种能够直接实例化。</p>
<p> 2、上文所列出的的 Buffer API 并没有包括存取函数。</p>
<p>这些方法都定义在Buffer类的子类中。子类包含了静态工厂方法用来创建相应类的新实例。以及get和put等操作来实现缓存区的存取。</p>
<p>我们以ByteBuffer类为例进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//缓冲区创建相关api</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array,<span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="comment">//缓存区存取相关API</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">( )</span></span>;<span class="comment">//从当前位置position上get，get之后，position会自动+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//从绝对位置get</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span></span>;<span class="comment">//从当前位置上普通，put之后，position会自动+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;<span class="comment">//从绝对位置上put</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的缓冲区是由分配(allocate)或包装(wrap)操作创建的。allocate操作创建一个缓冲区对象并分配一个私有的空间来储存容量大小的数据元素。wrap操作创建一个缓冲区对象但是==不分配任何空间==来储存数据元素。它使用您所提供的数组作为存储空间来储存缓冲区中的数据元素。 </p>
<p>存储操作是通过get和put操作进行的，get 和 put 可以是相对的或者是绝对的。在前面的程序列表中，相对方案是不带有索引参数的函数。当相对函数被调用时，位置在返回时前进一。如果位置前进过多，相对运算就会抛 出 异 常 。 对 于 put() ， 如 果 运 算 会 导 致 位 置 超 出 上 界 ， 就 会 抛 出BufferOverflowException 异常。对于 get()，如果位置不小于上界，就会抛出BufferUnderflowException 异常。绝对存取不会影响缓冲区的位置属性，但是如果您所提供的索引超出范围（负数或不小于上界），也将抛出 IndexOutOfBoundsException 异常。</p>
<p>下面我们通过详细的案例说明，如何创建缓冲区，以及对缓存区进行操作。</p>
<h4 id="2-1-创建缓冲区"><a href="#2-1-创建缓冲区" class="headerlink" title="2.1 创建缓冲区"></a>2.1 创建缓冲区</h4><p>对于这一讨论，我们将以 ByteBuffer 类为例，但是对于其它六种主要的缓冲区类也是适用的： IntBuffer， DoubleBuffer， ShortBuffer， LongBuffer， FloatBuffer，和 CharBuffer。下面是创建一个缓冲区的关键函数，对所有的缓冲区类通用（要按照需要替换类名）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferCreateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式1：allocate方式直接分配，内部将隐含的创建一个数组</span></span><br><span class="line">        ByteBuffer allocate = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//方式2：通过wrap根据一个已有的数组创建</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        ByteBuffer wrap = ByteBuffer.wrap(bytes);</span><br><span class="line">        <span class="comment">//方式3：通过wrap根据一个已有的数组指定区间创建</span></span><br><span class="line">        ByteBuffer wrapoffset = ByteBuffer.wrap(bytes,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//打印出刚刚创建的缓冲区的相关信息</span></span><br><span class="line">        print(allocate,wrap,wrapoffset);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Buffer... buffers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Buffer buffer : buffers) &#123;</span><br><span class="line">            System.out.println(<span class="string">"capacity="</span>+buffer.capacity()</span><br><span class="line">                    +<span class="string">",limit="</span>+buffer.limit()</span><br><span class="line">                    +<span class="string">",position="</span>+buffer.position()</span><br><span class="line">                    +<span class="string">",hasRemaining:"</span>+buffer.hasArray()</span><br><span class="line">                    +<span class="string">",remaining="</span>+buffer.remaining()</span><br><span class="line">                    +<span class="string">",hasArray="</span>+buffer.hasArray()</span><br><span class="line">                    +<span class="string">",isReadOnly="</span>+buffer.isReadOnly()</span><br><span class="line">                    +<span class="string">",arrayOffset="</span>+buffer.arrayOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">capacity=10,limit=10,position=0,hasRemaining:true,remaining=10,hasArray=true,isReadOnly=false,arrayOffset=0</span><br><span class="line">capacity=10,limit=10,position=0,hasRemaining:true,remaining=10,hasArray=true,isReadOnly=false,arrayOffset=0</span><br><span class="line">capacity=10,limit=7,position=2,hasRemaining:true,remaining=5,hasArray=true,isReadOnly=false,arrayOffset=0</span><br></pre></td></tr></table></figure>
<p>这段代码隐含地从堆空间中分配了一个 byte 型数组作为备份存储器来储存 10 个 byte变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];ByteBuffer wrap = ByteBuffer.wrap(bytes);</span><br></pre></td></tr></table></figure>
<p>这段代码构造了一个新的缓冲区对象，但数据元素会存在于数组中。这意味着通过调用put()函数造成的对缓冲区的改动会直接影响这个数组，而且对这个数组的任何改动也会对这个缓冲区对象可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer wrapoffset = ByteBuffer.wrap(bytes,<span class="number">2</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p><strong>==带有 offset 和 length 作为参数的 wrap()函数版本则会构造一个按照您提供的 offset 和 length 参数值初始化位置和上界的缓冲区。这个函数并不像您可能认为的那样，创建了一个只占用了一个数组子集的缓冲区。这个缓冲区可以存取这个数组的全部范围； offset 和 length 参数只是设置了初始的状态==。</strong></p>
<p>最后一个函数， arrayOffset()，返回缓冲区数据在数组中存储的开始位置的偏移量（从数组头 0 开始计算）。如果您使用了带有三个参数的版本的 wrap()函数来创建一个缓冲区，对于这个缓冲区， arrayOffset()会一直返回 0，像我们之前讨论的那样。</p>
<h4 id="2-2-缓冲区存取"><a href="#2-2-缓冲区存取" class="headerlink" title="2.2 缓冲区存取"></a>2.2 缓冲区存取</h4><p>让我们看一个例子。 我们将代表“Hello”字符串的 ASCII 码载入一个名为 buffer 的ByteBuffer 对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferPut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        print(buffer);</span><br><span class="line">        <span class="keyword">byte</span> H=<span class="number">0x48</span>;</span><br><span class="line">        <span class="keyword">byte</span> e=<span class="number">0x65</span>;</span><br><span class="line">        <span class="keyword">byte</span> l=<span class="number">0x6C</span>;</span><br><span class="line">        <span class="keyword">byte</span> o=<span class="number">0x6F</span>;</span><br><span class="line">        buffer.put(H).put(e).put(l).put(l).put(o);</span><br><span class="line">        print(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Buffer... buffers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Buffer buffer : buffers) &#123;</span><br><span class="line">            System.out.println(<span class="string">"capacity="</span>+buffer.capacity()</span><br><span class="line">                    +<span class="string">",limit="</span>+buffer.limit()</span><br><span class="line">                    +<span class="string">",position="</span>+buffer.position()</span><br><span class="line">                    +<span class="string">",hasRemaining:"</span>+buffer.hasArray()</span><br><span class="line">                    +<span class="string">",remaining="</span>+buffer.remaining()</span><br><span class="line">                    +<span class="string">",hasArray="</span>+buffer.hasArray()</span><br><span class="line">                    +<span class="string">",isReadOnly="</span>+buffer.isReadOnly()</span><br><span class="line">                    +<span class="string">",arrayOffset="</span>+buffer.arrayOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity=10,limit=10,position=0,hasRemaining:true,remaining=10,hasArray=true,isReadOnly=false,arrayOffset=0</span><br><span class="line">capacity=10,limit=10,position=5,hasRemaining:true,remaining=5,hasArray=true,isReadOnly=false,arrayOffset=0</span><br></pre></td></tr></table></figure>
<p><strong>五次调用 put()之后的缓冲区</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455604027086782.png" alt="Image.png"></p>
<p>注意本例中我们存储都是字节。</p>
<p>当然这样做是比较麻烦的，也有批量存储的方法，来取代面上一个一个字节的put</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(<span class="string">"Hello"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>既然我们已经在 buffer 中存放了一些数据，如果我们想在不丢失位置的情况下进行一些更改该怎么办呢？ put()的绝对方案可以达到这样的目的。假设我们想将缓冲区中的内容从“Hello”的 ASCII 码更改为“ Mellow”。我们可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> M=<span class="number">0x4D</span>;</span><br><span class="line"><span class="keyword">byte</span> w=<span class="number">0x77</span>;</span><br><span class="line">buffer.put(<span class="number">0</span>,M).put(w);</span><br></pre></td></tr></table></figure>
<p>这里通过进行一次绝对方案的 put 将 0 位置的字节代替为十六进制数值 0x4d，将 0x77放入当前位置（当前位置不会受到绝对 put()的影响）的字节，并将位置属性加一。结果如下所示</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455680392007615.png" alt="Image.png"></p>
<p><strong>翻转flip函数</strong></p>
<p>我们已经往缓冲区中存储了一些数据，现在我们想把它读取出来。但如果通道现在在缓冲区上执行 get()，那么它将从当前position位置开始读取，也就是我们刚刚插入的有用数据之外取出未定义数据。</p>
<p>如果我们将position值重新设为 0，就可以从正确位置开始获取，但是它是怎样知道何时到达我们所插入数据末端的呢？这就是limit上界属性被引入的目的。上界属性指明了缓冲区有效内容的末端。我们需要将上界属性设置为当前位置，然后将位置重置为 0。我们可以人工用下面的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.limit(buffer.position()).position(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>但这种从填充到释放状态的缓冲区翻转是 API 设计者预先设计好的，他们为我们提供了一个非常便利的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.flip();</span><br></pre></td></tr></table></figure>
<p>flip()函数将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态。在翻转之后，缓冲区的逻辑试图变成如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455754587098937.png" alt="Image.png"></p>
<p>rewind()函数与 flip()相似，但不影响上界属性。它只是将位置值设回 0。您可以使用 rewind()后退，重读已经被翻转的缓冲区中的数据。</p>
<p> 如果将缓冲区翻转两次会怎样呢？它实际上会大小变为 0。按照上图的相同步骤对缓冲区进行操作；把上界设为位置的值，并把位置设为 0。上界和位置都变成 0。尝试对缓冲区上位置和上界都为 0 的 get()操作会导致 <code>BufferUnderflowException</code> 异常。而 put()则会导致 <code>BufferOverflowException</code> 异常。</p>
<p>现在我们读取数据时，从position位置开始直到limit结束就可以了，布尔函数 hasRemaining()会在释放缓冲区时告诉您是否已经达到缓冲区的上界。以下是一种将数据元素从缓冲区释放到一个数组的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; buffer.hasRemaining( ), i++) &#123;</span><br><span class="line">      myByteArray [i] = buffer.get( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为选择， remaining()函数将告知您从当前位置到上界还剩余的元素数目。 您也可以通过下面的循环来释放缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = buffer.remaining( );    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">    myByteArray [i] = buffer.get( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您对缓冲区有专门的控制，这种方法会更高效，因为上界不会在每次循环重复时都被检查。</p>
<p>类似的put，get也有对应的批量操作，我们可以通过以下方式直接读取出，当前buffer中的所有元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">int</span> count = buffer.remaining( );</span><br><span class="line"><span class="keyword">byte</span>[] content=<span class="keyword">new</span>  <span class="keyword">byte</span>[count];<span class="comment">//构造一个与剩余可读元素大小相同的数组</span></span><br><span class="line">buffer.get(content);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(content));</span><br></pre></td></tr></table></figure>
<p>当读取完成之后，缓冲区试图如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455856965083181.png" alt="Image.png"></p>
<p><strong>清空clear函数</strong></p>
<p>当我们读取完了缓冲区的数据，为了重复利用缓冲区，我们可以通过clear函数来让缓冲区恢复到初始状态，它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回 0，即position=0，limit=capacity，mark=-1。</p>
<p>以下是Buffer类的clear方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    position = <span class="number">0</span>;    </span><br><span class="line">    limit = capacity;    </span><br><span class="line">    mark = -<span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空后的缓冲区视图如下所示</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455928294090896.png" alt="Image.png"></p>
<p><strong>标记 mark函数与reset函数</strong></p>
<p>在本章节的开头，我们已经涉及了缓冲区四种属性中的三种。第四种，mark，使缓冲区能够记住一个position并在之后将其返回。缓冲区的标记在 mark( )函数被调用之前是未定义的，值为-1，调用时mark被设为当前position的值。 reset( )函数将position设为当前的mark值。如果mark值未定义，调用 reset( )将导致 InvalidMarkException 异常。一些缓冲区函数rewind()、clear()、以及 flip()会抛弃已经设定的标记。</p>
<p>让我们看看这是如何进行的。对于’Mellow’放入ByteBuffer之后，并且执行了flip函数之后，如果执行以下代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.position(<span class="number">2</span>).mark().position(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>那么缓冲区逻辑试图如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483455982036044445.png" alt="Image.png"></p>
<p>如果现在从这个缓冲区读取数据，两个字节（“ ow”）将会被发送，而position会前进到 6。如果我们此时调用 reset( )，position将会被设为mark，如下图所示。再次将读取缓冲区的值将导致四个字节（“ llow”）被发送。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456005263067812.png" alt="Image.png"></p>
<p>mark可能没有什么实际意义，但你了解了概念。</p>
<p><strong>压缩(compact)</strong>     </p>
<p>有时，您可能只想从缓冲区中释放一部分数据，而不是全部，然后重新填充。为了实现这一点，未读的数据元素需要下移以使第一个元素索引为 0。尽管重复这样做会效率低下，但这有时非常必要，而 API 对此为您提供了一个 compact()函数。</p>
<p>下图显示了一个已经读取了前2个元素，并且现在我们想要对其进行压缩的缓冲区。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456072582059808.png" alt="Image.png"></p>
<p>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer.compact();</span><br></pre></td></tr></table></figure>
<p>会导致缓冲区如下图所示</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456117198030323.png" alt="Image.png"></p>
<p>这里发生了几件事。您会看到数据元素 2-5 被复制到 0-3 位置。位置 4 和 5 不受影响，但现在正在或已经超出了当前position，因此是“死的”。它们可以被之后的 put()调用重写。还要注意的是，position已经被设为被复制的数据元素的数目(4)。也就是说，缓冲区现在被定位在缓冲区中最后一个“存活”元素后插入数据的位置。最后，limit属性被设置为capacity的值，因此缓冲区可以被再次填满。调用 compact()的作用是丢弃已经释放的数据，保留未释放的数据，并使缓冲区对重新填充容量准备就绪。</p>
<p>如果您想在压缩后读取数据，缓冲区会像之前所讨论的那样需要被翻转(flip)。无论您之后是否要向缓冲区中添加新的数据，这一点都是必要的。</p>
<p><strong>压缩对于使缓冲区与您从端口中读入的数据（包）逻辑块流的同步来说也许是一种便利的方法(处理粘包、解包的问题)。</strong></p>
<p><strong>复制缓冲区duplicate()函数</strong></p>
<p>缓冲区的复制有分两种：</p>
<p>1、完全复制：调用duplicate()函数或者asReadOnlyBuffer()函数</p>
<p>2、部分复制：调用slice函数</p>
<p>duplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。</p>
<p>可以通过以下代码来复制一个缓冲区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buffer = CharBuffer.allocate (<span class="number">8</span>);</span><br><span class="line">buffer.position (<span class="number">3</span>).limit (<span class="number">6</span>).mark( ).position (<span class="number">5</span>);</span><br><span class="line">CharBuffer dupeBuffer = buffer.duplicate( );</span><br><span class="line">buffer.clear( );</span><br></pre></td></tr></table></figure>
<p>此时缓冲区的逻辑试图如下所示</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170103/1483456194499026001.png" alt="Image.png"></p>
<blockquote>
<p>图示的limit和capacity数字有误</p>
</blockquote>
<p>可以使用<code>asReadOnlyBuffer()</code>函数来生成一个只读的缓冲区视图 。 这与duplicate()相同，除了这个新的缓冲区不允许使用put()，并且其<code>isReadOnly()</code>函数将 会 返 回 true 。对这一只读缓冲区put()函数的调用尝试会导致抛出<code>ReadOnlyBufferException</code> 异常。</p>
<p><strong>直接缓冲区(direct byte buffer)</strong></p>
<p>直接字节缓冲区通常是 I/O 操作最好的选择。在设计方面，它们支持 JVM 可用的最高效I/O 机制。非直接字节缓冲区可以被传递给通道，但是这样可能导致性能损耗。通常非直接缓冲不可能成为一个本地 I/O 操作的目标。如果您向一个通道中传递一个非直接 ByteBuffer 对象用于写入，通道可能会在每次调用中隐含地进行下面的操作：</p>
<ol>
<li>创建一个临时的直接 ByteBuffer 对象。</li>
<li>将非直接缓冲区的内容复制到临时缓冲中。</li>
<li>使用临时缓冲区执行低层次 I/O 操作。</li>
<li>临时缓冲区对象离开作用域，并最终成为被回收的无用数据。</li>
</ol>
<p>这可能导致缓冲区在每个 I/O 上复制并产生大量对象，而这种事都是我们极力避免的。不过，依靠工具，事情可以不这么糟糕。运行时间可能会缓存并重新使用直接缓冲区或者执行其他一些聪明的技巧来提高吞吐量。如果您仅仅为一次使用而创建了一个缓冲区，区别并不是很明显。另一方面，如果您将在一段高性能脚本中重复使用缓冲区，分配直接缓冲区并重新使用它们会使您游刃有余。</p>
<p>==直接缓冲区时 I/O 的最佳选择==，但可能比创建非直接缓冲区要花费更高的成本。直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准 JVM 堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，这取决于主操作系统以及 JVM 实现。直接缓冲区的内存区域不受无用存储单元收集支配，因为它们位于标准 JVM 堆栈之外。</p>
<p>使用直接缓冲区或非直接缓冲区的性能权衡会因JVM，操作系统，以及代码设计而产生巨大差异。通过分配堆栈外的内存，您可以使您的应用程序依赖于JVM未涉及的其它力量。当加入其他的移动部分时，确定您正在达到想要的效果。我以一条旧的软件行业格言建议您：先使其工作，再加快其运行。不要一开始就过多担心优化问题；首先要注重正确性。 JVM实现可能会执行缓冲区缓存或其他的优化， 这会在不需要您参与许多不必要工作的情况下为您提供所需的性能。</p>
<p><strong>直接 ByteBuffer 是通过调用具有所需容量的== ByteBuffer.allocateDirect()==函数产生的</strong>，就像我们之前所涉及的 allocate()函数一样。注意用一个 wrap()函数所创建的被包装的缓冲区总是非直接的。</p>
<p>所有的缓冲区都提供了一个叫做 isDirect()的 boolean 函数，来测试特定缓冲区是否为直接缓冲区。虽然 ByteBuffer 是唯一可以被直接分配的类型，但如果基础缓冲区是一个直接 ByteBuffer，对于非字节视图缓冲区， isDirect()可以是 true。</p>
<p><strong>回顾我们之前讲解UNIX 五种IO模型中的读取数据的过程，读取数据总是需要通过内核空间传递到用户空间，而往外写数据总是要通过用户空间到内核空间。**</strong>JVM堆栈属于用户空间。<strong> </strong>而我们这里提到的直接缓冲区，就是内核空间的内存。内核空间的内存在java中是通过Unsafe这个类来调用的。**</p>
<p><strong>而Netty中所提到的零拷贝(通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间而直接在内核空间中传输到网络的方式)，无非就是使用了这里的直接缓冲区。没有什么神奇的。</strong></p>
<p><strong>内存映射缓冲区</strong></p>
<p>映射缓冲区是带有存储在文件，通过内存映射来存取数据元素的字节缓冲区。映射缓冲区通常是直接存取内存的，只能通过<code>FileChannel</code> 类创建。映射缓冲区的用法和直接缓冲区类似，但是 <code>MappedByteBuffer</code> 对象可以处理独立于文件存取形式的的许多特定字符。</p>
<p>==MappedByteBuffer在大文件处理方面性能比较高==，如果你在做一个文件存储服务器，可以考虑使用MappedByteBuffer。</p>
<h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3 Channel"></a>3 Channel</h2><h3 id="1-Channel简介"><a href="#1-Channel简介" class="headerlink" title="1 Channel简介"></a>1 Channel简介</h3><p>通道(Channel)可以理解为数据传输的管道。通道与流不同的是，==流只是在一个方向上移动(一个流必须是inputStream或者outputStream的子类)，而通道可以用于读、写或者同时用于读写==。</p>
<p><strong>channel 类的继承关系</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20180424/1524549616871070892.png" alt="A3C58E87-39CE-4DB5-92CE-5A8797F2E3F6.png"></p>
<p>为了保证尽可能清晰的显示我们关注的点，图中只显示了我们关心的Channel。</p>
<p>==I/O 可以分为广义的两大类别： File I/O 和 Stream I/O==。</p>
<p>那么相应地有两种类型的通道也就不足为怪了，它们是文件（ file）通道和套接字（ socket）通道。仔细看一下上图，你会发现有一个 <code>FileChannel</code> 类和三个 socket 通道类： <code>SocketChannel</code>、 <code>ServerSocketChannel</code> 和 <code>DatagramChannel</code>。</p>
<p><strong>通道可以是单向（ unidirectional）或者双向的（ bidirectional）</strong>。一个 channel 类可能实现定义read( )方法的 <code>ReadableByteChannel</code> 接口，而另一个 channel 类也许实现 <code>WritableByteChannel</code>接口以提供 write( )方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。</p>
<p>可以看到read和write方法接受的都是一个ByteBuffer参数，其中read方法，就是往ByteBuffer中put数据，write方法就是将ByteBuffer中的数据get出来，以便发送给其他远程主机。</p>
<p>两种方法均返回已传输的字节数，可能比缓冲区的字节数少甚至可能为零。缓冲区的position位置也会发生与已传输字节相同数量的前移。如果只进行了部分传输，缓冲区可以被重新提交给通道并从上次中断的地方继续传输。该过程重复进行直到缓冲区的 hasRemaining( )方法返回 false 值。</p>
<p>在上面的类图中，我们可以看到FileChannel、SocketChannel通道都实现了这两个接口。从类定义的角度而言，这意味着FileChannel、SocketChannel 通道对象都是双向的。这对于 SocketChannel 不是问题，因为它们一直都是双向的，不过对于FileChannel 却是个问题了。</p>
<p>我们知道，一个文件可以在不同的时候以不同的权限打开。从 FileInputStream 对象的getChannel( )方法获取的 FileChannel 对象是只读的，不过从接口声明的角度来看却是双向的，因为FileChannel 实现 ByteChannel 接口。在这样一个通道上调用 write( )方法将抛出未经检查的NonWritableChannelException 异常，因为 FileInputStream 对象总是以 read-only 的权限打开文件。</p>
<p>通道可以以多种方式创建。== Socket 通道有可以直接创建新 socket 通道的工厂方法。但是一个FileChannel 对象却只能通过在一个打开的 RandomAccessFile、 FileInputStream 或 FileOutputStream对象上调用 getChannel( )方法来获取。您不能直接创建一个 FileChannel 对象==。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, someport)); </span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</span><br><span class="line">ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (somelocalport)); </span><br><span class="line">DatagramChannel dc = DatagramChannel.open( ); </span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile (<span class="string">"somefile"</span>, <span class="string">"r"</span>);</span><br><span class="line">FileChannel fc = raf.getChannel( );</span><br></pre></td></tr></table></figure>
<p>java.net 的 socket 类也有新的 getChannel( )方法。这些方法虽然能返回一个相应的 socket 通道对象，但它们却并非新通道的来源，RandomAccessFile.getChannel( )方法才是。只有在已经有通道存在的时候，它们才返回与一个 socket 关联的通道；它们永远不会创建新通道。</p>
<h3 id="2-Socket通道详解"><a href="#2-Socket通道详解" class="headerlink" title="2 Socket通道详解"></a>2 Socket通道详解</h3><p>在通道类中，DatagramChannel 和 SocketChannel 实现定义读和写功能的接口而 ServerSocketChannel不实现。 ServerSocketChannel 负责监听传入的连接和创建新的 SocketChannel 对象，它本身从不传输数据。</p>
<p>==全部 NIO中的socket 通道类（ DatagramChannel、 SocketChannel 和 ServerSocketChannel）在被实例化时都会创建一个对等的BIO中的 socket 对象（ Socket、 ServerSocket和 DatagramSocket）==。</p>
<p>DatagramChannel、 SocketChannel 和 ServerSocketChannel通道类都定义了socket()方法，我们可以通过这个方法获取其关联的socket对象。另外每个Socket、 ServerSocket和 DatagramSocket都定义了getChannel()方法，来获取对应的通道。</p>
<p>需要注意是，==只有通过通道类创建的socket对象，其getChannel方法才能返回对应的通道，如果直接new了socket对象，那么其getChannel方法返回的永远是null==。</p>
<p><strong>非阻塞模式</strong></p>
<p>通道可以以阻塞（ blocking）或非阻塞（ nonblocking）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。</p>
<p>这个陈述虽然简单却有着深远的含义。传统 Java socket的阻塞性质曾经是 Java 程序可伸缩性的最重要制约之一。非阻塞 I/O 是许多复杂的、高性能的程序构建的基础。</p>
<p>回顾我们之前讲解的BIO编程中，不能<strong>“以尽可能少的线程，处理尽可能多的client请求”</strong>，就是因为通过Socket的getInputStream方法的read方法是阻塞的，一旦没有数据可读，处理线程就会被一直被block住。</p>
<p>默认情况下，一个通道创建，总是阻塞的，我们可以通过调用<code>configureBlocking(boolean)</code>方法即可，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。而 isBlocking()方法来判断某个 socket 通道当前处于哪种模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.configureBlocking (<span class="keyword">false</span>); </span><br><span class="line"><span class="comment">// nonblocking    ...   </span></span><br><span class="line"><span class="keyword">if</span> ( ! sc.isBlocking( )) &#123;       </span><br><span class="line">    doSomething (cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偶尔地，我们也会需要防止 socket 通道的阻塞模式被更改。 API 中有一个<code>blockingLock( )</code>方法，该方法会返回一个非透明的对象引用。返回的对象是通道实现修改阻塞模式时内部使用的。只有拥有此对象的锁的线程才能更改通道的阻塞模式，<strong>对于确保在执行代码的关键部分时 socket 通道的阻塞模式不会改变</strong>以及在不影响其他线程的前提下暂时改变阻塞模式来说，这个方法都是非常方便的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line">Object lockObj = serverChannel.blockingLock( );</span><br><span class="line"><span class="comment">// 执行关键代码部分的时候，使用这个锁进行同步</span></span><br><span class="line">synchronize (lockObj)&#123;</span><br><span class="line">    <span class="comment">// 一旦进入这个部分，锁就被获取到了，其他线程不能改变这个channel的阻塞模式</span></span><br><span class="line">    <span class="keyword">boolean</span> prevState = serverChannel.isBlocking( );</span><br><span class="line">    serverChannel.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">    socket = serverChannel.accept( );</span><br><span class="line">    serverChannel.configureBlocking (prevState);</span><br><span class="line">&#125;<span class="comment">// 释放锁，此时其他线程可以修改channel的阻塞模式</span></span><br><span class="line"><span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">    doSomethingWithTheSocket (socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-ServerSocketChannel"><a href="#2-1-ServerSocketChannel" class="headerlink" title="2.1 ServerSocketChannel"></a>2.1 ServerSocketChannel</h4><p>让我们从最简单的 ServerSocketChannel 来开始对 socket 通道类的讨论。</p>
<p>ServerSocketChannel 是一个基于通道的 socket 监听器。它同我们所熟悉的 java.net.ServerSocket执行相同的基本任务，不过它增加了通道语义，因此能够在非阻塞模式下运行。</p>
<p>用静态的 open( )工厂方法创建一个新的 ServerSocketChannel 对象，将会返回同一个未绑定的java.net.ServerSocket 关联的通道。该对等 ServerSocket 可以通过在返回的 ServerSocketChannel 上调用 socket( )方法来获取。作为 ServerSocketChannel 的对等体被创建的 ServerSocket 对象依赖通道实现。这些 socket 关联的 SocketImpl 能识别通道。通道不能被封装在随意的 socket 对象外面。</p>
<p>由于 ServerSocketChannel 没有 bind( )方法，因此有必要取出对等的 socket 并使用它来绑定到一个端口以开始监听连接。我们也是使用对等 ServerSocket 的 API 来根据需要设置其他的 socket 选项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</span><br><span class="line">ServerSocket serverSocket = ssc.socket( );</span><br><span class="line"><span class="comment">// Listen on port 1234</span></span><br><span class="line">serverSocket.bind (<span class="keyword">new</span> InetSocketAddress (<span class="number">1234</span>));</span><br></pre></td></tr></table></figure>
<p>同它的对等体 java.net.ServerSocket 一样， ServerSocketChannel 也有 accept( )方法。一旦您创建了一个 ServerSocketChannel 并用对等 socket 绑定了它，然后您就可以在其中一个上调用 accept( )。如果您选择在 ServerSocket 上调用 accept( )方法，那么它会同任何其他的 ServerSocket 表现一样的行为：总是阻塞并返回一个 java.net.Socket 对象。如果您选择在 ServerSocketChannel 上调用 accept( )方法则会返回 SocketChannel 类型的对象，返回的对象能够在非阻塞模式下运行。</p>
<p><strong>如果以非阻塞模式被调用，当没有传入连接在等待时， ServerSocketChannel.accept( )会立即返回 null</strong>。正是这种检查连接而不阻塞的能力实现了可伸缩性并降低了复杂性。可选择性也因此得到实现。我们可以使用一个选择器实例来注册一个 ServerSocketChannel 对象以实现新连接到达时自动通知的功能。下面的代码演示了如何使用一个非阻塞的 accept( )方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelAccept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING = <span class="string">"Hello I must be going.\r\n"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>; <span class="comment">// default</span></span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(GREETING.getBytes());</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Waiting for connections"</span>);</span><br><span class="line">            SocketChannel sc = ssc.accept();</span><br><span class="line">            <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// no connections, snooze a while</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                ByteBuffer allocate = ByteBuffer.allocateDirect (<span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">while</span>(sc.read(allocate)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    allocate.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining( )) &#123;</span><br><span class="line">                        <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">                        System.out.println(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                    allocate.clear();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                System.out.println(<span class="string">"Incoming connection from: "</span></span><br><span class="line">                        + sc.socket().getRemoteSocketAddress());</span><br><span class="line">                buffer.rewind();</span><br><span class="line">                sc.write(buffer);</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的作用是，在1234端口上接受client的请求，一旦接收到client的请求，会给其回复固定的字符串响应”Hello I must be going.”</p>
<p>运行这段程序，可以看到控制台打印出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Waiting for connections</span><br><span class="line">Waiting for connections</span><br><span class="line">Waiting for connections</span><br><span class="line">Waiting for connections</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>说明程序的确运行在非阻塞模式下，因为否则就会想ServerSocket.accpet方法那样，一直阻塞下去。</p>
<p>现在通过命令行执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost <span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>可以看到得到一个响应之后，连接立马关闭</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20180424/1524549629737056549.png" alt="BEA56C70-651E-4189-9001-97EAB22C47E0.png"></p>
<h4 id="2-2-SocketChannel"><a href="#2-2-SocketChannel" class="headerlink" title="2.2 SocketChannel"></a>2.2 SocketChannel</h4><p>下面开始学习 SocketChannel，它是使用最多的 socket 通道类：</p>
<p>Socket 和 SocketChannel 类封装点对点、有序的网络连接，就是我们所熟知并喜爱的 TCP/IP网络连接。 SocketChannel 扮演客户端发起同一个监听服务器的连接。直到连接成功，它才能收到数据并且只会从连接到的地址接收。</p>
<p>每个 SocketChannel 对象创建时都是同一个对等的 java.net.Socket 对象串联的。静态的 open( )方法可以创建一个新的 SocketChannel 对象，而在新创建的 SocketChannel 上调用 socket( )方法能返回它对等的 Socket 对象；在该 Socket 上调用 getChannel( )方法则能返回最初的那个 SocketChannel。</p>
<p>新创建的 SocketChannel 虽已打开却是未连接的。在一个未连接的 SocketChannel 对象上尝试一个 I/O 操作会导致 NotYetConnectedException 异常。我们可以通过在通道上直接调用 connect( )方法或在通道关联的 Socket 对象上调用 connect( )来将该 socket 通道连接。一旦一个 socket 通道被连接，它将保持连接状态直到被关闭。您可以通过调用布尔型的 isConnected( )方法来测试某个SocketChannel 当前是否已连接。</p>
<p>下面两段代码是等价的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过open方法</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, somePort));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过connect方法</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open( );</span><br><span class="line">socketChannel.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, somePort));</span><br></pre></td></tr></table></figure>
<p>如果您选择使用传统方式进行连接——通过在对等 Socket 对象上调用 connect( )方法，那么传统的连接语义将适用于此。线程在连接建立好或超时过期之前都将保持阻塞。如果您选择通过在通道上直接调用 connect( )方法来建立连接并且通道处于阻塞模式（默认模式），那么连接过程实际上是一样的。</p>
<p>在 SocketChannel 上并没有一种 connect( )方法可以让您指定超时（ timeout）值，当 connect( )方法在非阻塞模式下被调用时 SocketChannel 提供并发连接：它发起对请求地址的连接并且立即返回值。如果返回值是 true，说明连接立即建立了（这可能是本地环回连接）；如果连接不能立即建立， connect( )方法会返回 false 且并发地继续连接建立过程。</p>
<p>面向流的的 socket 建立连接状态需要一定的时间，因为两个待连接系统之间必须进行包对话以建立维护流 socket 所需的状态信息。跨越开放互联网连接到远程系统会特别耗时。假如某个SocketChannel 上当前正由一个并发连接， isConnectPending( )方法就会返回 true 值。</p>
<p>调用 finishConnect( )方法来完成连接过程，该方法任何时候都可以安全地进行调用。假如在一个非阻塞模式的 SocketChannel 对象上调用 finishConnect( )方法，将可能出现下列情形之一：</p>
<ul>
<li>connect( )方法尚未被调用。那么将产生 NoConnectionPendingException 异常。</li>
<li>连接建立过程正在进行，尚未完成。那么什么都不会发生， finishConnect( )方法会立即返回false 值。</li>
<li>在非阻塞模式下调用 connect( )方法之后， SocketChannel 又被切换回了阻塞模式。那么如果有必要的话，调用线程会阻塞直到连接建立完成， finishConnect( )方法接着就会返回 true值。</li>
<li>在初次调用 connect( )或最后一次调用 finishConnect( )之后，连接建立过程已经完成。那么SocketChannel 对象的内部状态将被更新到已连接状态， finishConnect( )方法会返回 true值，然后 SocketChannel 对象就可以被用来传输数据了。</li>
<li>连接已经建立。那么什么都不会发生， finishConnect( )方法会返回 true 值。</li>
</ul>
<p>当通道处于中间的连接等待（ connection-pending）状态时，您只可以调用 finishConnect( )、isConnectPending( )或 isConnected( )方法。一旦连接建立过程成功完成， isConnected( )将返回 true值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress (host, port);</span><br><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">sc.connect (addr);</span><br><span class="line"><span class="keyword">while</span> ( ! sc.finishConnect( )) &#123;</span><br><span class="line">   doSomethingElse( );</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithChannel (sc);</span><br><span class="line">sc.close( );</span><br></pre></td></tr></table></figure>
<h2 id="3-Channel案例"><a href="#3-Channel案例" class="headerlink" title="3 Channel案例"></a>3 Channel案例</h2><p>在这个案例中，我们使用nio中的channel+线程池，来实现TimeServer、TimeClient</p>
<p><strong>Server端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;SocketChannel&gt; idleQueue =<span class="keyword">new</span> LinkedBlockingQueue&lt;SocketChannel&gt;();</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;Future&lt;SocketChannel&gt;&gt; workingQueue=<span class="keyword">new</span> LinkedBlockingQueue&lt;Future&lt;SocketChannel&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span>  ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">   </span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                   <span class="comment">//task1：迭代当前idleQueue中的SocketChannel，提交到线程池中执行任务，并将其移到workingQueue中</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idleQueue.size(); i++) &#123;</span><br><span class="line">                            SocketChannel socketChannel = idleQueue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                Future&lt;SocketChannel&gt; result = executor.submit(<span class="keyword">new</span> TimeServerHandleTask(socketChannel), socketChannel);</span><br><span class="line">                                workingQueue.put(result);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//task2：迭代当前workingQueue中的SocketChannel，如果任务执行完成，将其移到idleQueue中</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workingQueue.size(); i++) &#123;</span><br><span class="line">                            Future&lt;SocketChannel&gt; future = workingQueue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (!future.isDone())&#123;</span><br><span class="line">                                workingQueue.put(future);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            SocketChannel channel  = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                channel = future.get();</span><br><span class="line">                                idleQueue.put(channel);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                                <span class="comment">//如果future.get()抛出异常，关闭SocketChannel，不再放回idleQueue</span></span><br><span class="line">                                channel.close();</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        TimeServer timeServer = <span class="keyword">new</span> TimeServer();</span><br><span class="line">        ServerSocketChannel ssc=ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            SocketChannel socketChannel = ssc.accept();</span><br><span class="line">            <span class="keyword">if</span>(socketChannel==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                timeServer.idleQueue.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SocketChannel socketChannel;</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line">   ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServerHandleTask</span><span class="params">(SocketChannel socketChannel, ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socketChannel = socketChannel;</span><br><span class="line">        <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(socketChannel.read(byteBuffer)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        <span class="keyword">if</span>(byteBuffer.remaining()&lt;<span class="string">"GET CURRENT TIME"</span>.length())&#123;</span><br><span class="line">                            byteBuffer.compact();</span><br><span class="line">                            socketChannel.read(byteBuffer);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">byte</span>[] request=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                        byteBuffer.get(request);</span><br><span class="line">                        String requestStr=<span class="keyword">new</span> String(request);</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">"GET CURRENT TIME"</span>.equals(requestStr)) &#123;</span><br><span class="line">                            socketChannel.write(byteBuffer.put(<span class="string">"BAD_REQUEST"</span>.getBytes()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ByteBuffer byteBuffer = <span class="keyword">this</span>.byteBuffer.put(Calendar.getInstance()</span><br><span class="line">                                           .getTime().toLocaleString().getBytes());</span><br><span class="line">                            byteBuffer.flip();</span><br><span class="line">                            socketChannel.write(byteBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                       </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                        TimeServerHandleTask currentTask = <span class="keyword">new</span> TimeServerHandleTask(socketChannel,</span><br><span class="line">                              executorService);</span><br><span class="line">                        executorService.submit(currentTask);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TimeServer中维护了两个队列，idleQueue 和workingQueue。</p>
<pre><code>工作步骤如下所示：

1、在main线程中，当接受到一个新的连接时，我们将相应的SocketChannel放入idleQueue。

2、在static静态代码块中，我们创建了一个Thread。其作用是不断的循环idleQueue和workingQueue。
</code></pre><p>首先循环idleQueue，迭代出其中的SocketChannel，然后封装成一个TimeServerHandleTask对象，提交到线程池中处理这个SocketChannel的请求，同时我们会将SocketChannel中移除，放到workingQueue中。需要注意的是，这个SocketChannel可能只是与服务端建立了连接，但是没有发送请求，又或者是发送了一次或者多次请求。发送一次”GET CURRENT TIME”，就相当于一次请求。在TimeServerHandleTask中，会判断是否发送了请求，如果没有请求则不需要处理。如果SocketChannel发送了多次请求，TimeServerHandleTask一次也只会处理一个请求。其他的请求等到下一次循环的时候再处理。因为使用线程池的情况，线程的数量有限，所以要合理的分配，不能让一个线程一直处理一个client的请求。</p>
<p>接着是迭代workingQueue，通过future.isDone()判断当前请求是否处理完成，如果处理完成，将其从workingQueue中移除，重新加入idleQueue中。 </p>
<p>TimeServerHandleTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandleTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   SocketChannel socketChannel;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TimeServerHandleTask</span><span class="params">(SocketChannel socketChannel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.socketChannel = socketChannel;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ByteBuffer requestBuffer = ByteBuffer.allocate(<span class="string">"GET CURRENT TIME"</span>.length());</span><br><span class="line">         <span class="comment">//尝试读取数据，因为是非阻塞，所以如果没有数据会立即返回。</span></span><br><span class="line">         <span class="keyword">int</span> bytesRead = socketChannel.read(requestBuffer);</span><br><span class="line">        <span class="comment">//如果没有读取到数据，说明当前SocketChannel并没有发送请求，不需要处理</span></span><br><span class="line">         <span class="keyword">if</span> (bytesRead &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果读取到了数据，则需要考虑粘包、解包问题，这个while代码是为了读取一个完整的请求信息"GET CURRENT TIME"，</span></span><br><span class="line">         <span class="keyword">while</span> (requestBuffer.hasRemaining()) &#123;</span><br><span class="line">            socketChannel.read(requestBuffer);</span><br><span class="line">         &#125;</span><br><span class="line">         String requestStr = <span class="keyword">new</span> String(requestBuffer.array());</span><br><span class="line">         <span class="keyword">if</span> (!<span class="string">"GET CURRENT TIME"</span>.equals(requestStr)) &#123;</span><br><span class="line">            String bad_request = <span class="string">"BAD_REQUEST"</span>;</span><br><span class="line">            ByteBuffer responseBuffer = ByteBuffer.allocate(bad_request.length());</span><br><span class="line">                responseBuffer.put(bad_request.getBytes());</span><br><span class="line">                responseBuffer.flip();</span><br><span class="line">                socketChannel.write(responseBuffer);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String timeStr = Calendar.getInstance().getTime().toLocaleString();</span><br><span class="line">                ByteBuffer responseBuffer = ByteBuffer.allocate(timeStr.length());</span><br><span class="line">                responseBuffer.put(timeStr.getBytes());</span><br><span class="line">                responseBuffer.flip();</span><br><span class="line">            socketChannel.write(responseBuffer);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>client端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> connectTimeOut=<span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">static</span> ByteBuffer buffer=ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis()-start&gt;=connectTimeOut)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"尝试建立连接超过3秒"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果走到这一步，说明连接建立成功</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            buffer.put(<span class="string">"GET CURRENT TIME"</span>.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">if</span>(socketChannel.read(buffer)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] response=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">                buffer.get(response);</span><br><span class="line">                System.out.println(<span class="string">"reveive response:"</span>+<span class="keyword">new</span> String(response));</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行server端，再运行client端，可以在client端看到类似以下的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reveive response:2016-12-18 21:52:09</span><br><span class="line">reveive response:2016-12-18 21:52:14</span><br><span class="line">reveive response:2016-12-18 21:52:19</span><br><span class="line">reveive response:2016-12-18 21:52:24</span><br><span class="line">reveive response:2016-12-18 21:52:29</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>到这里，我们好像已经可以达到我们的目标”以尽可能少的线程，处理尽可能多的client请求” ，但是现实总是残酷的，这个案例中代码的效率太低了。 </p>
<p>因为我们并不知道一个SocketChannel是否发送了请求，所以必须迭代所有的SocketChannel，然后尝试读取请求数据，如果有请求，就处理，否则就跳过。假设一个有10000个连接，前9999个连接都没有请求，刚好最后一个连接才有请求。那么前9999次任务处理都是没有必要的。</p>
<p>如果有一种方式，可以让我们直接获取到真正发送了请求的SocketChannel，那么效率将会高的多。</p>
<pre><code>这就是我们下一节将要讲解的Selector(选择器)，其可以帮助我们管理所有与server端已经建立了连接的client(SocketChannel)，并将准备好数据的client过滤出来。我们可以有一个专门的线程来运行Selector，将准备好数据的client交给工作线程来处理。 
</code></pre><h2 id="5-Selector"><a href="#5-Selector" class="headerlink" title="5 Selector"></a>5 Selector</h2><p>在本章中，我们将探索选择器(selectors)。<strong>==选择器提供选择执行已经就绪的任务的能力==</strong>，这使得多元 I/O 成为可能，就绪选择和多元执行使得单线程能够有效率地同时管理多个 I/O 通道(channels)。 C/C++代码的工具箱中，许多年前就已经有 select()和 poll()这两个POSIX（可移植性操作系统接口）系统调用可供使用了。许多操作系统也提供相似的功能，但对Java 程序员来说，就绪选择功能直到 JDK 1.4 才成为可行的方案。对于主要的工作经验都是基于Java 环境的开发的程序员来说，之前可能还没有碰到过这种 I/O 模型。</p>
<h3 id="1-选择器基础"><a href="#1-选择器基础" class="headerlink" title="1 选择器基础"></a>1 选择器基础</h3><p>在前面的讲解中，我们获取到<code>SocketChannel</code>之后，直接包装成一个任务，提交给线程池去处理了。而引入了Selector的概念之后， 我们需要将之前创建的一个或多个可选择的<code>Channel</code>注册到<code>Selector</code>对象中，一个键(<code>SelectionKey</code>)将会被返回。SelectionKey 会记住您关心的通道。它们也会追踪对应的通道是否已经就绪。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170104/1483540103154037014.png" alt="Image.png"></p>
<p>每个Channel在注册到Selector上的时候，都有一个感兴趣的操作。</p>
<ul>
<li>对于<code>ServerSocketChannel</code>，只会在选择器上注册一个，其感兴趣的操作是ACCEPT，表示其只关心客户端的连接请求</li>
<li>对于<code>SocketChannel</code>，通常会注册多个，因为一个server通常会接受到多个client的请求，就有对应数量的SocketChannel。SocketChannel感兴趣的操作是CONNECT、READ、WRITE，因为其要于server建立连接，也需要进行读、写数据。</li>
</ul>
<p>从最基础的层面来看，选择器提供了询问通道是否已经准备好执行每个 I/0 操作的能力。例如，我们需要了解一个 SocketChannel 对象是否还有更多的字节需要读取，或者我们需要知道ServerSocketChannel 是否有需要准备接受的连接。</p>
<p>当调用一个Selector对象的 select( )方法时，相关的SelectionKey 会被更新，用来检查所有被注册到该选择器的通道是否已经准备就绪。也就是说，程序需要主动的去调用Selector.select()方法。 select() 方法会返回一个准备就绪的SelectionKey的集合。通过遍历这些键，您可以选择出每个从上次您调用 select( )开始直到现在，已经就绪的通道。</p>
<p>在与 <code>SelectableChannel</code>联合使用时，就绪选择的真正价值在于潜在的大量的通道可以同时进行就绪状态的检查。调用者可以轻松地决定多个通道中的哪一个准备好要运行。有两种方式可以选择：被激发的线程可以处于休眠状态，直到一个或者多个注册到选择器的通道就绪，或者它也可以周期性地轮询选择器，看看从上次检查之后，是否有通道处于就绪状态。如果您考虑一下需要管理大量并发的连接的网络服务器(web server)的实现，就可以很容易地想到如何善加利用这些能力。</p>
<p>乍一看，好像只要非阻塞模式就可以模拟就绪检查功能，但实际上还不够。非阻塞模式同时还会执行您请求的任务，或指出它无法执行这项任务。这与检查它是否能够执行某种类型的操作是不同的。举个例子，如果您试图执行非阻塞操作，并且也执行成功了，您将不仅仅发现 read( )是可以执行的，同时您也已经读入了一些数据。就下来您就需要处理这些数据了。</p>
<p> <strong>效率上的要求使得您不能将检查就绪的代码和处理数据的代码分离开来，至少这么做会很复杂。</strong></p>
<p>即使简单地询问每个通道是否已经就绪的方法是可行的，在您的代码或一个类库的包里的某些代码需要遍历每一个候选的通道并按顺序进行检查的时候，仍然是有问题的。这会使得在检查每个通道是否就绪时都至少进行一次系统调用，这种代价是十分昂贵的，但是主要的问题是，这种检查不是原子性的。列表中的一个通道都有可能在它被检查之后就绪，但直到下一次轮询为止，您并不会觉察到这种情况。最糟糕的是，您除了不断地遍历列表之外将别无选择。您无法在某个您感兴趣的通道就绪时得到通知。</p>
<p>这就是为什么传统的监控多个 socket 的 Java 解决方案是为每个 socket 创建一个线程并使得线程可以在 read( )调用中阻塞，直到数据可用。这事实上==将每个被阻塞的线程当作了 socket 监控器，并将 Java 虚拟机的线程调度当作了通知机制==。这两者本来都不是为了这种目的而设计的。程序员和 Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价，这在线程数量的增长失控时表现得更为突出。</p>
<p>真正的就绪选择必须由操作系统来做。操作系统的一项最重要的功能就是处理 I/O 请求并通知各个线程它们的数据已经准备好了。选择器类提供了这种抽象，使得 Java 代码能够以可移植的方式，请求底层的操作系统提供就绪选择服务。</p>
<h4 id="1-1-创建选择器"><a href="#1-1-创建选择器" class="headerlink" title="1.1 创建选择器"></a>1.1 创建选择器</h4><p>Selector 对象是通过调用静态工厂方法 open( )来实例化的。选择器不是像通道或流(stream)那样的基本 I/O 对象：数据从来没有通过它们进行传递。类方法 open( )向 SPI 发出请求，通过默认的 SelectorProvider 对象获取一个新的实例。通过调用一个自定义的 SelectorProvider对象的 openSelector( )方法来创建一个 Selector 实例也是可行的。您可以通过调用 provider( )方法来决定由哪个 SelectorProvider 对象来创建给定的 Selector 实例。大多数情况下，您不需要关心 SPI;只需要调用 open( )方法来创建新的 Selector 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">Selector selector = Selector.open( );</span><br><span class="line"> </span><br><span class="line">方式二：</span><br><span class="line">SelectorProvider provider = SelectorProvider.provider();</span><br><span class="line">Selector abstractSelector = provider.openSelector();</span><br></pre></td></tr></table></figure>
<h5 id="1-2-1-注册通道到选择器上"><a href="#1-2-1-注册通道到选择器上" class="headerlink" title="1.2.1 注册通道到选择器上"></a>1.2.1 注册通道到选择器上</h5><p>注册通道到选择器上，是通过register方法进行的。</p>
<p>通道在被注册到一个选择器上之前，==必须先设置为非阻塞模式==（通过调用 <code>configureBlocking(false)</code>）。</p>
<p>如果您试图注册一个处于阻塞状态的通道， <code>register</code>( )将抛出未检查的 IllegalBlockingModeException 异常。此外，通道一旦被注册，就不能回到阻塞状态。试图这么做的话，将在调用 configureBlocking( )方法时将抛出<code>IllegalBlockingModeException</code>异常。并且，理所当然地，试图注册一个已经关闭的 SelectableChannel 实例的话，也将抛出<code>ClosedChannelException</code>异常，就像方法原型指示的那样。</p>
<p>注册通道的案例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc=ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">80</span>));</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">SelectionKey sscSelectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">//注册ServerSocketChannel</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel sc = ssc.accept();</span><br><span class="line">    <span class="keyword">if</span>(sc==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//注册SocketChannel</span></span><br><span class="line">    SelectionKey scselectionKey = sc.register(selector, SelectionKey.OP_ACCEPT | SelectionKey.OP_WRITE);</span><br><span class="line">    <span class="comment">//...其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  register( )方法接受一个 Selector 对象作为参数，以及一个名为ops 的整数参数。第二个参数表示所关心的通道操作，返回值是一个SelectionKey。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span></span><br></pre></td></tr></table></figure>
<p>ops值在 SelectonKey 类中被定义为 public static 字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到有四种被定义的可选择操作：读(read)，写(write)，连接(connect)和接受(accept)。</strong></p>
<p>并非所有的操作都在所有的可选择通道上被支持。例如， SocketChannel 不支持 accept。试图注册不支持的操作将导致 IllegalArgumentException。可以通过调用通道的 validOps( )方法来获取特定的通道所支持的操作集合。</p>
<p>SocketChannel支持的validOps ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span>...</span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (SelectionKey.OP_READ</span><br><span class="line">            | SelectionKey.OP_WRITE</span><br><span class="line">            | SelectionKey.OP_CONNECT);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerSocketChannel的validOps</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span>..</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SelectionKey.OP_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个通道可以被注册到多个选择器上，但对每个选择器而言，最好只注册一次。如果一个Selector上多次注册同一个Channel，返回的SelectionKey总是同一个实例，后注册的感兴趣的操作类型会覆盖之前的感兴趣的操作类型。 ==一个channel在不同的selector上注册， 每次返回的selectorKey都是一个不同的实例==。</p>
<h5 id="1-2-1-选择键-SelectionKey"><a href="#1-2-1-选择键-SelectionKey" class="headerlink" title="1.2.1 选择键(SelectionKey)"></a><strong>1.2.1 选择键(SelectionKey)</strong></h5><p>SelectionKey对象被register( )方法返回，并提供了方法来表示表示这种注册关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">( )</span></span>; <span class="comment">//获得这个SelectionKey关联的channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">( )</span></span>; <span class="comment">//获得这个selectionKey关联的Selector</span></span><br></pre></td></tr></table></figure>
<p>同时选择键包含指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interestOps</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="comment">//感兴趣兴趣的操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="comment">//感兴趣的操作中，已经准备就绪的操作</span></span><br></pre></td></tr></table></figure>
<p>可以通过调用键的 <code>readyOps</code>( )方法来获取相关的通道的已经就绪的操作。 ready 集合是 interest集合的子集 。当前的 interest 集合可以通过调用键对象的 <code>interestOps</code>( )方法来获取。最初，这应该是通道被注册时传进来的值。这个 interset 集合永远不会被选择器改变，用户可以通过调用 带参数的interestOps方法，并传入一个新的比特掩码参数来改变它。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interestOps</span> <span class="params">(<span class="keyword">int</span> ops)</span></span>;</span><br></pre></td></tr></table></figure>
<p>检查操作是否就绪  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps( ) &amp; SelectionKey.OP_READ) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">myBuffer.clear( );</span><br><span class="line">key.channel( ).read (myBuffer);</span><br><span class="line">doSomethingWithBuffer (myBuffer.flip( ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像之前提到过的那样，有四个通道操作可以被用于测试就绪状态。您可以像上面的代码那样，通过测试比特掩码来检查这些状态，但 SelectionKey 类定义了四个便于使用的布尔方法来为您测试这些比特值： <code>isReadable</code>( )， <code>isWritable</code>( )， <code>isConnectable</code>( )， 和 <code>isAcceptable</code>( )。每一个方法都与使用特定掩码来测试 readyOps( )方法的结果的效果相同。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isWritable( ))</span><br><span class="line">等价于：</span><br><span class="line"><span class="keyword">if</span> ((key.readyOps( ) &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这四个方法在任意一个 SelectionKey 对象上都能安全地调用。</p>
<p>需要注意的是，通过相关的选择键的 readyOps( )方法返回的就绪状态指示只是一个提示，不是保证。底层的通道在任何时候都会不断改变。其他线程可能在通道上执行操作并影响它的就绪状态。同时，操作系统的特点也总是需要考虑的。</p>
<p>SelectionKey对象表示了一种特定的注册关系。当应该终结这种关系的时候，可以调用 SelectionKey对象的 cancel( )方法。 当键被取消时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用 select( )方法时（或者一个正在进行的 select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。</p>
<p>通道会被注销，而新的SelectionKey 将被返回。</p>
<p>当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出 CancelledKeyException。</p>
<h3 id="1-2-使用选择器"><a href="#1-2-使用选择器" class="headerlink" title="1.2 使用选择器"></a>1.2 使用选择器</h3><p>既然我们已经很好地掌握了了各种不同类以及它们之间的关联，那么现在让我们进一步了解Selector 类，也就是就绪选择的核心。这里是 Selector 类的可用的 API。在之前，我们已经看到如何创建新的选择器，那么那些方法还剩下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// This is a partial API listing</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set <span class="title">keys</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set <span class="title">selectedKeys</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-1-选择过程"><a href="#1-2-1-选择过程" class="headerlink" title="1.2.1 选择过程"></a>1.2.1 选择过程</h4><p>在详细了解 API 之前，您需要知道一点和 Selector 内部工作原理相关的知识。就像上面探讨的那样，选择器维护着注册过的通道的集合，并且这些注册关系中的任意一个都是封装在SelectionKey 对象中的。<strong>每一个 Selector 对象维护三个键的集合</strong>：</p>
<p><strong>已注册的键的集合(Registered key set)</strong></p>
<p>与选择器关联的已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过keys( )方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引 java.lang.UnsupportedOperationException。</p>
<p><strong>已选择的键的集合(Selected key set)</strong></p>
<p>已注册的键的集合的子集。这个集合的每个成员都是相关的通道被选择器（在前一个选择操作中）判断为已经准备好的，并且包含于键的 interest 集合中的操作。这个集合通过 selectedKeys( )方法返回（并有可能是空的）。</p>
<p>不要将已选择的键的集合与 ready 集合弄混了。这是一个键的集合，每个键都关联一个已经准备好至少一种操作的通道。每个键都有一个内嵌的 ready 集合，指示了所关联的通道已经准备好的操作。(readyOps，一个通道可能对多个操作感兴趣，ready的可能只是其中某个操作)。SelectionKey可以直接从这个集合中移除，但不能添加。试图向已选择的键的集合中添加元素将抛出java.lang.UnsupportedOperationException。</p>
<p><strong>已取消的键的集合(Cancelled key set)</strong></p>
<p>已注册的键的集合的子集，这个集合包含了 cancel( )方法被调用过的键（这个键已经被无效化），但==它们还没有被注销==。这个集合是选择器对象的私有成员，因而无法直接访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSelector</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Selector</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; cancelledKeys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();<span class="comment">//取消的keys</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet();<span class="comment">//选择的key</span></span><br><span class="line">    <span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet();<span class="comment">//注册的keys</span></span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个刚初始化的 Selector 对象中，这三个集合都是空的。</p>
<p>Selector 类的核心是选择过程。这个名词您已经在之前看过多次了——现在应该解释一下了。基本上来说，选择器是对 select( )、 poll( )等本地调用(native call)或者类似的操作系统特定的系统调用的一个包装。但是 Selector 所作的不仅仅是简单地向本地代码传送参数。它对每个选择操作应用了特定的过程。对这个过程的理解是合理地管理键和它们所表示的状态信息的基础。</p>
<p>Selector 类的 select( )方法有以下三种不同的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<p>这三种 select 的形式，仅仅在它们在所注册的通道当前都没有就绪时，是否阻塞的方面有所不同。最简单的没有参数的形式可以用如下方式调用：</p>
<ol>
<li><strong>select()，</strong>这种调用在没有通道就绪时将无限阻塞。一旦至少有一个已注册的通道就绪，选择器的选择键就会被更新，并且每个就绪的通道的 ready 集合也将被更新。返回值将会是已经确定就绪的通道的数目。正常情况下， 这些方法将返回一个非零的值，因为直到一个通道就绪前它都会阻塞。但是它也可以返回非 0 值，如果选择器的 wakeup( )方法被其他线程调用。</li>
<li><strong>select (long timeout)</strong> ：有时您会想要限制线程等待通道就绪的时间。这种情况下，可以使用一个接受一个超时参数的select( long timeout)方法的重载形式：这种调用与之前的例子完全相同，除了如果在您提供的超时时间（以毫秒计算）内没有通道就绪时，它将返回 0。如果一个或者多个通道在时间限制终止前就绪，键的状态将会被更新，并且方法会在那时立即返回。将超时参数指定为 0 表示将无限期等待，那么它就在各个方面都等同于使用无参数版本的 select( )了。</li>
<li><strong>selectNow( )</strong> ：就绪选择的第三种也是最后一种形式是完全非阻塞的：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = selector.selectNow( );</span><br></pre></td></tr></table></figure>
<p>selectNow()方法执行就绪检查过程，但不阻塞。如果当前没有通道就绪，它将立即返回 0。</p>
<p>选择操作是当三种形式的 select( )中的任意一种被调用时，由选择器执行的。不管是哪一种形式的调用，下面步骤将被执行：</p>
<p> <strong>1</strong>、已取消的键的集合将会被检查。如果它是非空的，每个已取消的键的集合中的键将从另外两个集合中移除，并且相关的通道将被注销。这个步骤结束后，已取消的键的集合将是空的。</p>
<p> 2、已注册的键的集合中的键的 interest 集合将被检查。在这个步骤中的检查执行过后，对interest 集合的改动不会影响剩余的检查过程。一旦就绪条件被定下来，底层操作系统将会进行查询，以确定每个通道所关心的操作的真实就绪状态。依赖于特定的 select( )方法调用，如果没有通道已经准备好，线程可能会在这时阻塞，通常会有一个超时值。 直到系统调用完成为止，这个过程可能会使得调用线程睡眠一段时间，然后当前每个通道的就绪状态将确定下来。对于那些还没准备好的通道将不会执行任何的操作。对于那些操作系统指示至少已经准备好 interest 集合中的一种操作的通道，将执行以下两种操作中的一种：</p>
<p>   a.如果通道的键还没有处于已选择的键的集合中，那么键的 ready 集合将被清空，然后表示操作系统发现的当前通道已经准备好的操作的比特掩码将被设置。</p>
<p>   b.否则，也就是键在已选择的键的集合中。键的 ready 集合将被表示操作系统发现的当前已经准备好的操作的比特掩码更新。所有之前的已经不再是就绪状态的操作不会被清除。事实上，所有的比特位都不会被清理。由操作系统决定的 ready 集合是与之前的 ready 集合按位分离的，一旦键被放置于选择器的已选择的键的集合中，它的 ready 集合将是累积的。比特位只会被设置，不会被清理。</p>
<p> <strong>3.</strong>步骤 2 可能会花费很长时间，特别是所激发的线程处于休眠状态时。与该选择器相关的键可能会同时被取消。当步骤 2 结束时，步骤 1 将重新执行，以完成任意一个在选择进行的过程中，键已经被取消的通道的注销。</p>
<p> <strong>4</strong>.select 操作返回的值是 ready 集合在步骤 2 中被修改的键的数量，而不是已选择的键的集合中的通道的总数。返回值不是已准备好的通道的总数，而是从上一个 select( )调用之后进入就绪状态的通道的数量。之前的调用中就绪的，并且在本次调用中仍然就绪的通道不会被计入，而那些在前一次调用中已经就绪但已经不再处于就绪状态的通道也不会被计入。这些通道可能仍然在已选择的键的集合中，但不会被计入返回值中。返回值可能是 0。</p>
<p>使用内部的已取消的键的集合来延迟注销，是一种防止线程在取消键时阻塞，并防止与正在进行的选择操作冲突的优化。注销通道是一个潜在的代价很高的操作，这可能需要重新分配资源（请记住，键是与通道相关的，并且可能与它们相关的通道对象之间有复杂的交互）。清理已取消的键，并在选择操作之前和之后立即注销通道，可以消除它们可能正好在选择的过程中执行的潜在棘手问题。这是另一个兼顾健壮性的折中方案。</p>
<h3 id="1-2-2-停止选择过程"><a href="#1-2-2-停止选择过程" class="headerlink" title="1.2.2 停止选择过程"></a><strong>1.2.2 停止选择过程</strong></h3><p>Selector 的 API 中的最后一个方法， wakeup( )，提供了使线程从被阻塞的 select( )方法中优雅地退出的能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">( )</span></span>;</span><br></pre></td></tr></table></figure>
<p>有三种方式可以唤醒在 select( )方法中睡眠的线程：</p>
<p><strong>调用 wakeup( )</strong></p>
<p>调用 Selector 对象的 wakeup( )方法将使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有在进行中的选择，那么下一次对 select( )方法的一种形式的调用将立即返回。后续的选择操作将正常进行。在选择操作之间多次调用 wakeup( )方法与调用它一次没有什么不同。</p>
<p>有时这种延迟的唤醒行为并不是您想要的。您可能只想唤醒一个睡眠中的线程，而使得后续的选择继续正常地进行。您可以通过在调用 wakeup( )方法后调用 selectNow( )方法来绕过这个问题。尽管如此，如果您将您的代码构造为合理地关注于返回值和执行选择集合，那么即使下一个 select( )方法的调用在没有通道就绪时就立即返回，也应该不会有什么不同。不管怎么说，您应该为可能发生的事件做好准备。</p>
<p><strong>调用 close( )</strong></p>
<p>如果Selector的 close( )方法被调用，那么任何一个在选择操作中阻塞的线程都将被唤醒，就像wakeup( )方法被调用了一样。与选择器相关的通道将被注销， 而键将被取消。</p>
<p><strong>调用 interrupt( )</strong></p>
<p>如果睡眠中的线程的 interrupt( )方法被调用，它的返回状态将被设置。如果被唤醒的线程之后将试图在通道上执行 I/O 操作，通道将立即关闭，然后线程将捕捉到一个异常。这是由于在第三章中已经探讨过的通道的中断语义。使用 wakeup( )方法将会优雅地将一个在 select( )方法中睡眠的线程唤醒。如果您想让一个睡眠的线程在直接中断之后继续执行，需要执行一些步骤来清理中断状态（参见 Thread.interrupted( )的相关文档）。Selector 对象将捕捉 InterruptedException 异常并调用 wakeup( )方法。请注意这些方法中的任意一个都不会关闭任何一个相关的通道。中断一个选择器与中断一个通道是不一样的。选择器不会改变任意一个相关的通道，它只会检查它们的状态。当一个在 select( )方法中睡眠的线程中断时，对于通道的状态而言，是不会产生歧义的。</p>
<h3 id="1-3-3-管理选择键"><a href="#1-3-3-管理选择键" class="headerlink" title="1.3.3 管理选择键"></a>1.3.3 管理选择键</h3><p>既然我们已经理解了问题的各个部分是怎样结合在一起的，那么是时候看看它们在正常的使用中是如何交互的了。为了有效地利用选择器和键提供的信息，合理地管理键是非常重要的。</p>
<p>选择是累积的。一旦一个选择器将一个键添加到它的已选择的键的集合中，它就不会移除这个键。并且，一旦一个键处于已选择的键的集合中，这个键的 readyOPS将只会被设置，而不会被清理。乍一看，这好像会引起麻烦，因为选择操作可能无法表现出已注册的通道的正确状态。它提供了极大的灵活性，但把合理地管理键以确保它们表示的状态信息不会变得陈旧的任务交给了程序员。</p>
<p>合理地使用选择器的秘诀是理解选择器维护的选择键集合所扮演的角色。（参见 4.3.1 小节，特别是选择过程的第二步。）最重要的部分是当键已经不再在已选择的键的集合中时将会发生什么。当Channel上的至少一个感兴趣的操作就绪时，SelectionKey的 readyOps就会被清空，并且当前已经就绪的操作将会被添加到 readyOps中。该键之后将被添加到已选择的键的集合中。</p>
<p>清理一个 SelectKey 的 readyOps的方式是将这个键从已选择的键的集合中移除(例如一个读操作准备好，读取完数据后，这个通道就不再是读操作准备好)。选择键的就绪状态只有在选择器对象在选择操作过程中才会修改。处理思想是只有在已选择的键的集合中的键才被认为是包含了合法的就绪信息的。这些信息将在键中长久地存在，直到键从已选择的键的集合中移除，以通知选择器您已经看到并对它进行了处理。如果下一次通道的一些感兴趣的操作发生时，键将被重新设置以反映当时通道的状态并再次被添加到已选择的键的集合中。</p>
<p>这种框架提供了很多灵活性。通常的做法是在选择器上调用一次 select 操作(这将更新已选择的键的集合)，然后遍历 selectKeys( )方法返回的键的集合。在按顺序进行检查每个键的过程中，相关的通道也根据键的就绪集合进行处理。然后键将从已选择的键的集合中被移除（通过在 Iterator对象上调用 remove( )方法），然后检查下一个键。完成后，通过再次调用 select( )方法重复这个循环。例 4-1 中的代码是典型的服务器的例子。</p>
<p><strong>使用 select( )来为多个通道提供服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> selector;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by TIANSHOUZHI336 on 2016/7/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectableChannel;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple echo-back server which listens for incoming stream connections and</span></span><br><span class="line"><span class="comment"> * echoes back whatever it reads. A single Selector object is used to listen to</span></span><br><span class="line"><span class="comment"> * the server socket (to accept new connections) and all the active socket</span></span><br><span class="line"><span class="comment"> * channels.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSockets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT_NUMBER = <span class="number">1234</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SelectSockets().go(argv);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = PORT_NUMBER;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123; <span class="comment">// Override default listen port</span></span><br><span class="line">            port = Integer.parseInt(argv[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Listening on port "</span> + port);</span><br><span class="line"><span class="comment">// Allocate an unbound server socket channel</span></span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// Get the associated ServerSocket to bind it with</span></span><br><span class="line">        ServerSocket serverSocket = serverChannel.socket();</span><br><span class="line"><span class="comment">// Create a new Selector for use below</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// Set the port the server channel will listen to</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"><span class="comment">// Set nonblocking mode for the listening socket</span></span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Register the ServerSocketChannel with the Selector</span></span><br><span class="line">        SelectionKey selectionKey = serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">// This may block for a long time. Upon returning, the</span></span><br><span class="line"><span class="comment">// selected set contains keys of the ready channels.</span></span><br><span class="line">            <span class="keyword">int</span> n = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;<span class="comment">//什么情况下会返回0？</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// nothing to do</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// Get an iterator over the set of selected keys</span></span><br><span class="line">            Iterator it = selector.selectedKeys().iterator();</span><br><span class="line"><span class="comment">// Look at each key in the selected set</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = (SelectionKey) it.next();</span><br><span class="line"><span class="comment">// Is a new connection coming in?</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;<span class="comment">//对应SelectionKey.OP_ACCEPT操作</span></span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    registerChannel(selector, channel,SelectionKey.OP_READ);</span><br><span class="line">                    sayHello(channel);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// Is there data to read on this channel?</span></span><br><span class="line"><span class="comment">//对应SelectionKey.OP_READ操作，注意这个key是ServerSocketChannel的SelectionKey</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    readDataFromSocket(key);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// Remove key from selected set; it's been handled</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register the given channel with the given selector for the given</span></span><br><span class="line"><span class="comment">     * operations of interest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(Selector selector,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   SelectableChannel channel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// could happen</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// Set the new channel nonblocking</span></span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Register it with the selector</span></span><br><span class="line">        channel.register(selector, ops);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Use the same byte buffer for all channels. A single thread is</span></span><br><span class="line"><span class="comment">// servicing all the channels, so no danger of concurrent acccess.</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sample data handler method for a channel with data ready to read.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key A SelectionKey object associated with a channel determined by</span></span><br><span class="line"><span class="comment">     *            the selector to be ready for reading. If the channel returns</span></span><br><span class="line"><span class="comment">     *            * an EOF condition, it is closed here, which automatically</span></span><br><span class="line"><span class="comment">     *            invalidates the associated key. The selector will then</span></span><br><span class="line"><span class="comment">     *            de-register the channel on the next select call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        buffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line"><span class="comment">// Loop while data is available; channel is nonblocking</span></span><br><span class="line">        <span class="keyword">while</span> ((count = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip(); <span class="comment">// Make buffer readable</span></span><br><span class="line"><span class="comment">// Send the data; don't assume it goes all at once</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// WARNING: the above loop is evil. Because</span></span><br><span class="line"><span class="comment">// it's writing back to the same nonblocking</span></span><br><span class="line"><span class="comment">// channel it read the data from, this code can</span></span><br><span class="line"><span class="comment">// potentially spin in a busy loop. In real life</span></span><br><span class="line"><span class="comment">// you'd do something more useful than this.</span></span><br><span class="line">            buffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// Close channel on EOF, invalidates the key</span></span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spew a greeting to the incoming client connection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel The newly connected SocketChannel to say hello to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(<span class="string">"Hi there!\r\n"</span>.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例实现了一个简单的服务器。它创建了 ServerSocketChannel 和 Selector 对象，并将通道注册到选择器上。我们不在注册的键中保存服务器 socket 的引用，因为它永远不会被注销。这个无限循环在最上面先调用了 select( )，这可能会无限期地阻塞。当选择结束时，就遍历选择键并检查已经就绪的通道。</p>
<p>如果一个键指示与它相关的通道已经准备好执行一个 accecpt( )操作，我们就通过键获取关联的通道，并将它转换为 SeverSocketChannel 对象。我们都知道这么做是安全的，因为只有ServerSocketChannel 支持 OP_ACCEPT 操作。我们也知道我们的代码只把对一个单一的ServerSocketChannel 对象的 OP_ACCEPT 操作进行了注册。通过对服务器 socket 通道的引用，我们调用了它的 accept( )方法，来获取刚到达的 socket 的句柄。返回的对象的类型是SocketChannel，也是一个可选择的通道类型。这时，与创建一个新线程来从新的连接中读取数据不同，我们只是简单地将 socket 同多注册到选择器上。我们通过传入 OP_READ 标记，告诉选择器我们关心新的 socket 通道什么时候可以准备好读取数据。</p>
<p>如果键指示通道还没有准备好执行 accept( )，我们就检查它是否准备好执行 read( )。任何一个这么指示的 socket 通道一定是之前 ServerSocketChannel 创建的 SocketChannel 对象之一，并且被注册为只对读操作感兴趣。对于每个有数据需要读取的 socket 通道，我们调用一个公共的方法来读取并处理这个带有数据的 socket。需要注意的是这个公共方法需要准备好以非阻塞的方式处理 socket 上的不完整的数据。它需要迅速地返回，以其他带有后续输入的通道能够及时地得到处理。例 4-1 中只是简单地对数据进行响应，将数据写回 socket，传回给发送者。</p>
<p>在循环的底部，我们通过调用 Iterator（迭代器）对象的 remove()方法，将键从已选择的键的集合中移除。键可以直接从 selectKeys()返回的 Set 中移除，但同时需要用 Iterator 来检查集合，您需要使用迭代器的 remove()方法来避免破坏迭代器内部的状态。</p>
<h3 id="1-4-并发性"><a href="#1-4-并发性" class="headerlink" title="1.4 并发性"></a>1.4 并发性</h3><p>选择器对象是线程安全的，但它们包含的键集合不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet();<span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet();<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; cancelledKeys = <span class="keyword">new</span> HashSet&lt;SelectionKey&gt;();</span><br></pre></td></tr></table></figure>
<p>可以看到选择键的集合是HashSet类型，HashSet是线程不安全。</p>
<p>  通过 keys( )和 selectKeys( )返回的键的集合是 Selector 对象内部的私有的 Set 对象集合的直接引用。这些集合可能在任意时间被改变。已注册的键的集合是只读的。如果您试图修它 ， 那么您得到的奖品将是一个java.lang.UnsupportedOperationException。</p>
<p>但是当您在观察它们的时候，它们可能发生了改变的话，您仍然会遇到麻烦。 Iterator 对象是快速失败的(fail-fast)：如果底层的 Set 被改变了，它们将会抛出 java.util.ConcurrentModificationException，因此如果您期望在多个线程间共享选择器和/或键，请对此做好准备。您可以直接修改选择键，但请注意您这么做时可能会彻底破坏另一个线程的 Iterator。</p>
<p>如果在多个线程并发地访问一个选择器的键的集合的时候存在任何问题，您可以采取一些步骤来合理地同步访问。在执行选择操作时，选择器在 Selector 对象上进行同步，然后是已注册的键的集合，最后是已选择的键的集合，按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步（当与已取消的键的集合相关的通道被注销时）。</p>
<p>在多线程的场景中，如果您需要对任何一个键的集合进行更改，不管是直接更改还是其他操作带来的副作用，您都需要首先以相同的顺序，在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁，就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器，那么就不必要进行同步了。</p>
<p>  Selector 类的 close( )方法与 select( )方法的同步方式是一样的，因此也有一直阻塞的可能性。在选择过程还在进行的过程中，所有对 close( )的调用都会被阻塞，直到选择过程结束，或者执行选择的线程进入睡眠。在后面的情况下，执行选择的线程将会在执行关闭的线程获得锁是立即被唤醒，并关闭选择器 。</p>
<h3 id="1-5-异步关闭能力"><a href="#1-5-异步关闭能力" class="headerlink" title="1.5 异步关闭能力"></a>1.5 异步关闭能力</h3><p>任何时候都有可能关闭一个通道或者取消一个选择键。除非您采取步骤进行同步，否则键的状态及相关的通道将发生意料之外的改变。一个特定的键的集合中的一个键的存在并不保证键仍然是有效的，或者它相关的通道仍然是打开的。</p>
<p>关闭通道的过程不应该是一个耗时的操作。 NIO 的设计者们特别想要阻止这样的可能性：一个线程在关闭一个处于选择操作中的通道时，被阻塞于无限期的等待。当一个通道关闭时，它相关的键也就都被取消了。这并不会影响正在进行的 select( )，但这意味着在您调用 select( )之前仍然是有效的键，在返回时可能会变为无效。您总是可以使用由选择器的 selectKeys( )方法返回的已选择的键的集合：请不要自己维护键的集合。理解 之前描述的选择过程，对于避免遇到问题而言是非常重要的。</p>
<p>如果您试图使用一个已经失效的键，大多数方法将抛出 CancelledKeyException。但是，您可以安全地从从已取消的键中获取通道的句柄。如果通道已经关闭时，仍然试图使用它的话，在大多数情况下将引发 ClosedChannelException。</p>
<h3 id="1-6-选择过程的可扩展性"><a href="#1-6-选择过程的可扩展性" class="headerlink" title="1.6 选择过程的可扩展性"></a>1.6 选择过程的可扩展性</h3><p>我多次提到选择器可以简化用单线程同时管理多个可选择通道的实现。使用一个线程来为多个通道提供服务，通过消除管理各个线程的额外开销，可能会降低复杂性并可能大幅提升性能。但只使用一个线程来服务所有可选择的通道是否是一个好主意呢？这要看情况。</p>
<p>对单 CPU 的系统而言这可能是一个好主意，因为在任何情况下都只有一个线程能够运行。通过消除在线程之间进行上下文切换带来的额外开销，总吞吐量可以得到提高。但对于一个多 CPU的系统呢？在一个有 n 个 CPU 的系统上，当一个单一的线程线性地轮流处理每一个线程时，可能有 n-1 个 cpu 处于空闲状态。</p>
<p>那么让不同道请求不同的服务类的办法如何？想象一下，如果一个应用程序为大量的分布式的传感器记录信息。每个传感器在服务线程遍历每个就绪的通道时需要等待数秒钟。这在响应时间不重要时是可以的。但对于高优先级的连接（如操作命令），如果只用一个线程为所有通道提供服务，将不得不在队列中等待。不同的应用程序的要求也是不同的。您采用的策略会受到您尝试解决的问题的影响。</p>
<p>在第一个场景中，如果您想要将更多的线程来为通道提供服务，请抵抗住使用多个选择器的欲望。在大量通道上执行就绪选择并不会有很大的开销，大多数工作是由底层操作系统完成的。管理多个选择器并随机地将通道分派给它们当中的一个并不是这个问题的合理的解决方案。这只会形成这个场景的一个更小的版本。</p>
<p>一个更好的策略是对所有的可选择通道使用一个选择器，并将对就绪通道的服务委托给其他线程。您只用一个线程监控通道的就绪状态并使用一个协调好的工作线程池来处理共接收到的数据。根据部署的条件，线程池的大小是可以调整的（或者它自己进行动态的调整）。对可选择通道的管理仍然是简单的，而简单的就是好的。</p>
<p>第二个场景中，某些通道要求比其他通道更高的响应速度，可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。但这种场景也可以使用与第一个场景十分相似的办法来解决。与将所有准备好的通道放到同一个线程池的做法不同，通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池，命令/控制线程池，状态请求线程池，等等。</p>
<p>由于执行选择过程的线程将重新循环并几乎立即再次调用 select( )，键的 interest 集合将被修改，并将 interest（感兴趣的操作）从读取就绪(read-rreadiness)状态中移除。这将防止选择器重复地调用 readDataFromSocket( )（因为通道仍然会准备好读取数据，直到工作线程从它那里读取数据）。当工作线程结束为通道提供的服务时，它将再次更新键的 ready 集合，来将 interest 重新放到读取就绪集合中。它也会在选择器上显式地嗲用 wakeup( )。如果主线程在 select( )中被阻塞，这将使它继续执行。这个选择循环会再次执行一个轮回（可能什么也没做）并带着被更新的键重新进入select( )。</p>
<p>基于Selector+Channel+线程池的Timeserver</p>
<h2 id="6-基于Selector-Channel-线程池的Timeserver"><a href="#6-基于Selector-Channel-线程池的Timeserver" class="headerlink" title="6 基于Selector+Channel+线程池的Timeserver"></a>6 基于Selector+Channel+线程池的Timeserver</h2><p>基于Selector+Channel+线程池的Timeserver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, ssc.validOps());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> readyCount = selector.select(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span>(readyCount==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey selectionKey = keyIterator.next();</span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isValid())&#123;</span><br><span class="line">                    <span class="comment">//表示ServerSocketChannel</span></span><br><span class="line">                    <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                        SocketChannel socketChannel = server.accept();</span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//表示SocketChannel</span></span><br><span class="line">                    <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                        executor.submit(<span class="keyword">new</span> TimeServerTask(selectionKey));</span><br><span class="line">                    &#125;</span><br><span class="line">                    keyIterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SelectionKey selectionKey;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServerTask</span><span class="params">(SelectionKey selectionKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selectionKey = selectionKey;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) selectionKey.channel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((count = channel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">byte</span>[] request=<span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                byteBuffer.get(request);</span><br><span class="line">                String requestStr=<span class="keyword">new</span> String(request);</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"GET CURRENT TIME"</span>.equals(requestStr)) &#123;</span><br><span class="line">                    channel.write(byteBuffer.put(<span class="string">"BAD_REQUEST"</span>.getBytes()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    byteBuffer.put(Calendar.getInstance().getTime().toLocaleString().getBytes());</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    channel.write(byteBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            selectionKey.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的实现中：</p>
<p>1 把Channel的就绪选择放在了主线程(Acceptor线程)中来处理(等待数据准备阶段)</p>
<p>2 而真正的读取请求并返回响应放在了线程池中提交一个任务来执行(处理数据阶段)</p>
<p>真正意义上实现了一个线程服务于多个client</p>
<p>TimeClient直接使用上一节的即可</p>
<h1 id="2-0-Netty入门案例"><a href="#2-0-Netty入门案例" class="headerlink" title="2.0 Netty入门案例"></a>2.0 Netty入门案例</h1><p>在本节中，我们将前面讲解NIO编程时的时间服务案例，改成用Netty来实现。TimeClient发送“QUERY TIME ORDER”请求，TimeServer接受到这个请求后，返回当前时间。</p>
<p>Server端代码</p>
<p><strong>TimeServer</strong></p>
<p>时间服务器TimeServer在8080端口监听客户端请求，如下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port=<span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> TimeServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">           </span><br><span class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (5)</span></span><br><span class="line">            System.out.println(<span class="string">"TimeServer Started on 8080..."</span>);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TimeServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>1、首先我们创建了两个<code>EventLoopGroup</code>实例：bossGroup和workerGroup，目前可以将bossGroup和workerGroup理解为两个线程池。其中bossGroup用于接受客户端连接，bossGroup在接受到客户端连接之后，将连接交给workerGroup来进行处理。</p>
<p>2、接着，我们创建了一个<code>ServerBootstrap</code>实例，从名字上就可以看出来这是一个服务端启动类，我们需要给设置一些参数，包括第1步创建的bossGroup和workerGroup。</p>
<p>3、我们通过channel方法指定了<code>NioServerSocketChannel</code>，这是netty中表示服务端的类，用于接受客户端连接，对应于java.nio包中的ServerSocketChannel。</p>
<p>4、我们通过childHandler方法，设置了一个匿名内部类<code>ChannelInitializer</code>实例，用于初始化客户端连接<code>SocketChannel</code>实例。在第3步中，我们提到NioServerSocketChannel是用于接受客户端连接，在接收到客户端连接之后，netty会回调ChannelInitializer的initChannel方法需要对这个连接进行一些初始化工作，主要是告诉netty之后如何处理和响应这个客户端的请求。在这里，主要是添加了3个ChannelHandler实例：<code>LineBasedFrameDecoder</code>、<code>StringDecoder</code>、TimeServerHandler。其中LineBasedFrameDecoder、StringDecoder是netty本身提供的，用于解决TCP粘包、解包的工具类。</p>
<ul>
<li>LineBasedFrameDecoder在解析客户端请求时，遇到字符”\n”或”\r\n”时则认为是一个完整的请求报文，然后将这个请求报文的二进制字节流交给StringDecoder处理。</li>
<li>StringDecoder将字节流转换成一个字符串，交给TimeServerHandler来进行处理。</li>
<li>TimeServerHandler是我们自己要编写的类，在这个类中，我们要根据用户请求返回当前时间。</li>
</ul>
<p>5、在所有的配置都设置好之后，我们调用了ServerBootstrap的bind(port)方法，开启真正的监听在8080端口，接受客户端请求。 </p>
<p><strong>TimeServerHandler</strong></p>
<p><code>TimeServerHandler</code>用户处理客户端的请求，每当接收到”QUERY TIME ORDER”请求时，就返回当前时间，否则返回”BAD REQUEST”。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// 1</span></span><br><span class="line">        String request = (String) msg; <span class="comment">//2</span></span><br><span class="line">        String response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"QUERY TIME ORDER"</span>.equals(request)) &#123; <span class="comment">// 3</span></span><br><span class="line">            response = <span class="keyword">new</span> Date(System.currentTimeMillis()).toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = <span class="string">"BAD REQUEST"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response = response + System.getProperty(<span class="string">"line.separator"</span>); <span class="comment">// 4</span></span><br><span class="line">        ByteBuf resp = Unpooled.copiedBuffer(response.getBytes()); <span class="comment">// 5</span></span><br><span class="line">        ctx.writeAndFlush(resp); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<pre><code>1、`TimeServerHandler`继承了`ChannelInboundHandlerAdapter`，并覆盖了channelRead方法，当客户端发送了请求之后，channelRead方法会被回调。参数`ChannelHandlerContext`包含了当前发送请求的客户端的一些上下文信息，msg表示客户端发送的请求信息。

2、我们直接msg强制转换成了String类型。这是因为我们在前面已经添加过了StringDecoder，其已经将二进制流转换成了一个字符串

3、构建响应。会判断请求是否合法，如果请求信息是&quot;QUERY TIME ORDER”，则返回当前时间，否则返回&quot;BAD REQUEST”

4、在响应内容中加上了System.getProperty(&quot;line.separator”)，也就是所谓的换行符。在linux操作系统中，就是”\n”，在windows操作系统是”\r\n”。加上换行符，主要是因为客户端也要对服务端的响应进行解码，当遇到一个换行符时，就认为是一个完整的响应。

5、调用了`Unpooled.copiedBuffer`方法创建了一个缓冲区对象`ByteBuf`。在java nio包中，使用ByteBuffer类来表示一个缓冲区对象。在netty中，使用ByteBuf表示一个缓冲区对象。在后面的章节中，我们会对ByteBuf进行详细讲解。

6、调用ChannelHandlerContext的writeAndFlush方法，将响应刷新到客户端
</code></pre><p>Client端代码</p>
<p><strong>TimeClient</strong></p>
<p>TimeClient负责与服务端的8080端口建立连接 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = <span class="string">"localhost"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(workerGroup); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">// (4)</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<pre><code>1、首先我们创建了一个`Bootstrap`实例，与ServerBootstrap相对应，这表示一个客户端的启动类

2、我们调用group方法给Bootstrap实例设置了一个EventLoopGroup实例。前面提到，EventLoopGroup的作用是线程池。前面在创建ServerBootstrap时，设置了一个bossGroup，一个wrokerGroup，这样做主要是为将接受连接和处理连接请求任务划分开，以提升效率。对于客户端而言，则没有这种需求，只需要设置一个EventLoopGroup实例即可。

3、通过channel方法指定了`NioSocketChannel`，这是netty在nio编程中用于表示客户端的对象实例。

4、类似server端，在连接创建完成，初始化的时候，我们也给SocketChannel添加了几个处理器类。其中TimeClientHandler是我们自己编写的给服务端发送请求，并接受服务端响应的处理器类。

5、所有参数设置完成之后，调用Bootstrap的connect(host, port)方法，与服务端建立连接。
</code></pre><p><strong>TimeClientHandler</strong></p>
<p><code>TimeClientHandler</code>主要用于给Server端发送”QUERY TIME ORDER”请求，并接受服务端响应。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] req=(<span class="string">"QUERY TIME ORDER"</span> + System.getProperty(<span class="string">"line.separator"</span>)).getBytes();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;<span class="comment">//1</span></span><br><span class="line">        ByteBuf message = Unpooled.buffer(req.length);</span><br><span class="line">        message.writeBytes(req);</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String body = (String) msg;</span><br><span class="line">        System.out.println(<span class="string">"Now is:"</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<pre><code>1、TimeClientHandler继承了ChannelInboundHandlerAdapter，并同时覆盖了channelActive和channelRead方法。
</code></pre><ul>
<li>当客户端与服务端连接==建立成功==后，channelActive方法会被回调，我们在这个方法中给服务端发送”QUERY TIME ORDER”请求。</li>
<li>当接受到服务端==响应==后，channelRead方法会被会回调，我们在这个方法中打印出响应的时间信息。</li>
</ul>
<p><strong>运行案例</strong></p>
<p>首先启动服务端，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeServer Started on 8080...</span><br></pre></td></tr></table></figure>
<p>接着启动客户端，控制要输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Now is:Wed Apr <span class="number">25</span> <span class="number">00</span>:<span class="number">39</span>:<span class="number">14</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p>至此，我们入门案例已经完成。 </p>
<h1 id="3-0-Channel"><a href="#3-0-Channel" class="headerlink" title="3.0 Channel"></a>3.0 Channel</h1><p>Netty中通道是对java原生网络编程api的封装，其顶级接口是Channel。</p>
<p>以TCP编程为例 ，在java中，有两种方式：</p>
<ol>
<li>基于BIO，JDK1.4之前，我们通常使用java.net包中的<code>ServerSocket</code>和<code>Socket</code>来代表服务端和客户端。</li>
<li>基于NIO，Jdk1.4引入nio编程之后，我们使用java.nio.channels包中的<code>ServerSocketChannel</code>和<code>SocketChannel</code>来代表服务端与客户端。</li>
</ol>
<p>在Netty中，对java中的BIO、NIO编程api都进行了封装，分别：</p>
<ol>
<li>使用了<code>OioServerSocketChannel</code>，<code>OioSocketChannel</code>对java.net包中的ServerSocket与Socket进行了封装</li>
<li>使用<code>NioServerSocketChannel</code>和<code>NioSocketChannel</code>对java.nio.channels包中的ServerSocketChannel和SocketChannel进行了封装。</li>
</ol>
<p><strong>Netty中TCP编程的Channel类图继承关系如下：</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258359783066030.png" alt="Image.png"></p>
<p>很容易可以看出，图中左半部分与右半部分是相互对应的：</p>
<p>  左半部分代表的是客户端：都实现了SocketChannel接口</p>
<p>  右半部分代表的是服务端：都实现了<code>ServerChannel</code>接口，这是一个标记接口。</p>
<p>特别需要注意的是，虽然Netty使用通道的概念，对java原生BIO、NIO编程api都进行了封装，但是通道的概念其实是在java 1.4之后引入nio编程才出现的，因此只有NioServerSocketChannel和NioSocketChannel才有对应的java通道，可以看到这二者都继承自<code>AbstractNioChannel</code>，其维护了netty中的channel与java nio中channel的对应关系，并提供了<code>javaChannel()</code>方法获取对应的java 中的channel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNioChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</span><br><span class="line"> ...</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> SelectableChannel <span class="title">javaChannel</span><span class="params">()</span> </span>&#123;<span class="comment">//获取对应的java通道</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码片段中<code>SelectableChannel</code>是java nio中的类，我们前面提到nio包中的SocketChannel、ServerSocketChannel都是其子类</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258459031010273.png" alt="Image.png"></p>
<p>NioSocketChannel和NioServerSocketChannel对AbstractNioChannel的javaChannel()进行了覆写，如下：</p>
<p><strong>io.netty.channel.socket.nio.NioServerSocketChannel#javaChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overrideprotected</span> <span class="function">ServerSocketChannel <span class="title">javaChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回java.nio.channels.ServerSocketChannel  </span></span><br><span class="line">    <span class="keyword">return</span> (ServerSocketChannel) <span class="keyword">super</span>.javaChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>io.netty.channel.socket.nio.NioSocketChannel#javaChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overrideprotected</span> <span class="function">SocketChannel <span class="title">javaChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//返回java.nio.channels.SocketChannel    </span></span><br><span class="line">    <span class="keyword">return</span> (SocketChannel) <span class="keyword">super</span>.javaChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于OioSocketChannel和OioServerSocketChannel，是直接继承自AbstractChannel，内部直接维护了对应的Socket和ServerSocket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OioSocketChannel</span> <span class="keyword">extends</span> <span class="title">OioByteStreamChannel</span>                              <span class="keyword">implements</span> <span class="title">SocketChannel</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractOioMessageChannel</span>                                    <span class="keyword">implements</span> <span class="title">ServerSocketChannel</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">final</span> ServerSocket socket;</span><br><span class="line">    ...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-ChannelConfig"><a href="#3-1-ChannelConfig" class="headerlink" title="3.1 ChannelConfig"></a>3.1 ChannelConfig</h2><p>在Netty中，每种Channel都有对应的配置，用<code>ChannelConfig</code>来表示，ChannelConfig是一个接口，每个特定的Channel实现类都有自己对应的ChannelConfig实现类，如：</p>
<p>1、NioSocketChannel的对应的配置类为<code>NioSocketChannelConfig</code></p>
<p>2、NioServerSocketChannel的对应的配置类为NioServerSocketChannelConfig</p>
<p><strong>ChannelConfig的部分类图继承关系如下：</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486258662091064940.png" alt="Image.png"></p>
<p>在Channel接口中定义了一个方法<code>config()</code>，用于获取特定通道实现的配置，子类需要实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">AttributeMap</span>, <span class="title">Comparable</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function">ChannelConfig <span class="title">config</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常Channel实例，在创建的时候，就会创建其对应的ChannelConfig实例。例如NioServerSocketChannel和NioSocketChannel都是在构造方法中创建了其对应的ChannelConfig实现。</p>
<p><strong>NioServerSocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioMessageChannel</span></span></span><br><span class="line"><span class="class">                             <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">ServerSocketChannel</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannelConfig config;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    <span class="comment">//构造方法中创建NioServerSocketChannelConfig实例</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannelConfig <span class="title">config</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//覆写config方法，返回ServerSocketChannelConfig实例</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NioSocketChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioByteChannel</span> <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">SocketChannel</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannelConfig config;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;<span class="comment">//构造方法中创建SocketChannelConfig实例</span></span><br><span class="line">    <span class="keyword">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannelConfig <span class="title">config</span><span class="params">()</span> </span>&#123;<span class="comment">//覆写config方法，返回SocketChannelConfig实例</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Netty提供了一个ChannelOption类，其定义了ChannelConfig支持的所有参数类型</strong>，可以认为ChannelConfig中用了一个Map来保存参数，Map的key是ChannelOption，ChannelConfig 定义了相关方法来获取和修改Map中的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelConfig</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    Map&lt;ChannelOption&lt;?&gt;, Object&gt; getOptions();<span class="comment">//获取所有参数</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">setOptions</span><span class="params">(Map&lt;ChannelOption&lt;?&gt;, ?&gt; options)</span></span>;<span class="comment">//替换所有参数</span></span><br><span class="line">   &lt;T&gt; <span class="function">T <span class="title">getOption</span><span class="params">(ChannelOption&lt;T&gt; option)</span></span>;<span class="comment">//获取以某个ChannelOption为key的参数值</span></span><br><span class="line">   &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">setOption</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span></span>;<span class="comment">//替换某个ChannelOption为key的参数值</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想修改一个Map中的参数时，例如我们希望NioSocketChannel在工作过程中，使用<code>PooledByteBufAllocator</code>来分配内存，则可以使用类似以下方式来设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel ch = ...;</span><br><span class="line">   SocketChannelConfig cfg = (SocketChannelConfig) ch.getConfig();</span><br><span class="line">   cfg.setOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>特别的，针对每个ChannelOption选项，还提供了一个便捷的方法来设置参数，例如下面的代码与上述代码是等价的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel ch = ...;</span><br><span class="line">   SocketChannelConfig cfg = (SocketChannelConfig) ch.getConfig();</span><br><span class="line">   cfg.setAllocator(PooledByteBufAllocator.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>因为在ChannelConfig的默认实现<code>DefaultChannelConfig</code>中，<code>setOption</code>方法内部还是通过判断ChanneOption方法来选择对应的方法设置的。</p>
<p>io.netty.channel.DefaultChannelConfig#setOption</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelConfig</span> <span class="keyword">implements</span> <span class="title">ChannelConfig</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">setOption</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    validate(option, value);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (option == CONNECT_TIMEOUT_MILLIS) &#123;<span class="comment">//判断ChannelOption类型，再调用对应的方法</span></span><br><span class="line">        setConnectTimeoutMillis((Integer) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == MAX_MESSAGES_PER_READ) &#123;</span><br><span class="line">        setMaxMessagesPerRead((Integer) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_SPIN_COUNT) &#123;</span><br><span class="line">        setWriteSpinCount((Integer) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == ALLOCATOR) &#123;</span><br><span class="line">        setAllocator((ByteBufAllocator) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == RCVBUF_ALLOCATOR) &#123;</span><br><span class="line">        setRecvByteBufAllocator((RecvByteBufAllocator) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == AUTO_READ) &#123;</span><br><span class="line">        setAutoRead((Boolean) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == AUTO_CLOSE) &#123;</span><br><span class="line">        setAutoClose((Boolean) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_BUFFER_HIGH_WATER_MARK) &#123;</span><br><span class="line">        setWriteBufferHighWaterMark((Integer) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == WRITE_BUFFER_LOW_WATER_MARK) &#123;</span><br><span class="line">        setWriteBufferLowWaterMark((Integer) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == MESSAGE_SIZE_ESTIMATOR) &#123;</span><br><span class="line">        setMessageSizeEstimator((MessageSizeEstimator) value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是上述类型，返回false，表示不支持此ChannelOpiton</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中，我们还可以注意到另外一点，ChannelConfig接口的默认实现DefaultChannelConfig只支持了部分ChannelOption类型，这是所有的Channel都支持的ChannelOpiton。</p>
<p>ChannelConfig的特定子类在DefaultChannelConfig的基础上，支持更多的ChannelOption 。</p>
<p><strong>ChannelConfig支持的通用ChannelOption</strong></p>
<ul>
<li>ChannelOption.CONNECT_TIMEOUT_MILLIS</li>
<li>ChannelOption.WRITE_SPIN_COUNT</li>
<li>ChannelOption.ALLOCATOR</li>
<li>ChannelOption.AUTO_READ</li>
<li>ChannelOption.MAX_MESSAGES_PER_READ</li>
<li>ChannelOption.RCVBUF_ALLOCATOR</li>
<li>ChannelOption.ALLOCATOR</li>
<li>ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</li>
<li>ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</li>
<li>ChannelOption.MESSAGE_SIZE_ESTIMATOR</li>
<li>ChannelOption.AUTO_CLOSE</li>
</ul>
<p>事实上这里的每一种ChannelOption，除了可以使用setOption方法来进行设置，在ChannelConfig接口中都为其设置了对应的快捷set/get方法，不再赘述。</p>
<p><strong>SocketChannelConfig在ChannelConfig基础上额外支持的ChannelOption</strong></p>
<ul>
<li>ChannelOption.SO_KEEPALIVE</li>
<li>ChannelOption.SO_REUSEADDR</li>
<li>ChannelOption.SO_LINGER</li>
<li>ChannelOption.TCP_NODELAY</li>
<li>ChannelOption.SO_RCVBUF</li>
<li>ChannelOption.SO_SNDBUF</li>
<li>ChannelOption.IP_TOS</li>
<li>ChannelOption.ALLOW_HALF_CLOSURE</li>
</ul>
<p><strong>ServerSocketChannelConfig**</strong>在ChannelConfig基础上<strong>**额外支持的ChannelOption</strong></p>
<ul>
<li>ChannelOption.SO_REUSEADDR</li>
<li>ChannelOption.SO_RCVBUF</li>
<li>ChannelOption.SO_BACKLOG</li>
</ul>
<p><strong>细心的读者会发现，除了ChannelConfig接口中定义的公共ChannelOption，SocketChannelConfig 和ServerSocketChannelConfig 支持的ChannelOption基本上都是TCP连接参数相关的</strong>，基本上每一个都对应<code>java.net.StandardSocketOptions</code> 定义的一个标准TCP参数，下面逐一进行讲解。</p>
<p><strong>ChannelOption讲解</strong></p>
<p><strong>ChannelOption.SO_KEEPALIVE</strong>–&gt;StandardSocketOptions.SO_KEEPALIVE</p>
<p>是否启用==心跳机制==,默认false。</p>
<p>套接字本身是有一套心跳保活机制的，不过默认的设置并不像我们一厢情愿的那样有效。在双方TCP套接字建立连接后（即都进入ESTABLISHED状态）并且在两个小时左右上层没有任何数据传输的情况下，这套机制才会被激活。</p>
<p>很多人认为两个小时的时间设置得很不合理。为什么不设置成为10分钟，或者更短的时间？（可以通过SO_KEEPALIVE选项设置。）但是这样做其实并不被推荐。实际上这套机制只是操作系统底层使用的一个被动机制，原理上不应该被上层应用层使用。当系统关闭一个由KEEPALIVE机制检查出来的死连接时，是不会主动通知上层应用的，只有在调用相应的IO操作在返回值中检查出来。</p>
<p>在《UNIX网络编程第1卷》中也有详细的阐述：</p>
<p>SO_KEEPALIVE 保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方 发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节.它会导致以下三种情况：对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接口本身则被关闭。对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT，套接口本身则被关闭。如ICMP错误是“host unreachable(主机不可达)”，说明对方主机并没有崩溃，但是不可达，这种情况下待处理错误被置为 EHOSTUNREACH。</p>
<p>因此，忘记SO_KEEPALIVE，在应用层自己写一套保活机制比较靠谱。</p>
<p><strong>ChannelOption.SO_REUSEADDR–&gt;</strong>StandardSocketOptions.SO_REUSEADDR</p>
<p>是否重用处于TIME_WAIT状态的地址。默认为false。</p>
<p><strong>ChannelOption.SO_LINGER–&gt;</strong>StandardSocketOptions.SO_LINGER</p>
<p>优雅地关闭套接字，或者立刻关闭。当调用closesocket关闭套接字时，SO_LINGER将决定系统如何处理残存在套接字发送队列中的数据。处理方式无非两种：丢弃或者将数据继续发送至对端，优雅关闭连接。事实上，SO_LINGER并不被推荐使用，大多数情况下我们推荐使用默认的关闭方式。SO_LINGER 以秒为单位，最大取值为65535，也就是说，指定时间内残余数据尚未发送完成，那么也立即关闭。</p>
<p><strong>ChannelOption.SO_SNDBUF–&gt;</strong>StandardSocketOptions.SO_SNDBUF</p>
<p>发送缓冲区的大小设置，默认为8K。</p>
<p><strong>ChannelOption.SO_RCVBUF–&gt;</strong>StandardSocketOptions.SO_RCVBUF</p>
<p>接收缓冲区大小设置，默认为8K。该属性既可以在ServerSocket实例中设置，也可以在Socket实例中设置。</p>
<p><strong>ChannelOption.TCP_NODELAY–&gt;</strong>StandardSocketOptions.TCP_NODELAY</p>
<p>是否一有数据就马上发送。在TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，==TCP总是希望尽可能的发送足够大的数据==。这里就涉及到一个名为Nagle的算法，该算法的目的就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</p>
<p>TCP_NODELAY选项，就是用于启用或关于Nagle算法。如果要求高实时性，有数据发送时就马上发送，就将该选项设置为true关闭Nagle算法；如果要减少发送次数减少网络交互，就设置为false等累积一定大小后再发送。默认为false。</p>
<p><strong>ChannelOption.IP_TOS–&gt;</strong>StandardSocketOptions.IP_TOS</p>
<p><strong>ChannelOption#SO_BACKLOG</strong></p>
<p>BACKLOG用于构造服务端套接字ServerSocket对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度。如果未设置或所设置的值小于1，Java将使用默认值50。在Netty中，这个值默认是去读取文件/proc/sys/net/core/somaxconn的值，如果没有读到，默认取值为3072(参见：<code>NetUtil.SOMAXCONN</code>)。</p>
<p>理解了这些参数之后，还有一点需要注意的是，由于Netty只是对java网络编程API的一层封装，因此表面上NioSocketChannelConfig、NioServerSocketChannelConfig 包含的参数分别设置给了NioSocketChannel，NioServerSocketChannel。但事实上这些参数必须要设置给java原生的Socket对象才能生效。</p>
<p>以NioSocketChannelConfig为例，NioSocketChannel创建的时候，就会创建其对应的NioSocketChannelConfig实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioByteChannel</span> <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">SocketChannel</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannelConfig config;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;<span class="comment">//构造方法中传入了java原生socket对象参数</span></span><br><span class="line">    <span class="keyword">super</span>(parent, socket);</span><br><span class="line">    config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 在创建NioSocketChannelConfig实例的时候，传递了2个参数，一个是this，即当前NioSocketChannel，另外一个是通过SocketChannel的socket方法获得的原生socket。</p>
<p>当NioSocketChannelConfig相关设置ChannelOption的方法被调用时，则会直接将参数设置给对应的socket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title">DefaultChannelConfig</span></span></span><br><span class="line"><span class="class">                                              <span class="keyword">implements</span> <span class="title">ServerSocketChannelConfig</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Socket javaSocket;</span><br><span class="line">.....</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannelConfig <span class="title">setTcpNoDelay</span><span class="params">(<span class="keyword">boolean</span> tcpNoDelay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        javaSocket.setTcpNoDelay(tcpNoDelay);<span class="comment">//直接将参数设置给了对应的java Socket</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-ChannelHander"><a href="#3-2-ChannelHander" class="headerlink" title="3.2 ChannelHander"></a>3.2 ChannelHander</h2><p>在nio编程中，我们经常需要对channel的输入和输出事件进行处理，Netty抽象出一个<code>ChannelHandler</code>概念，专门用于处理此类事件。</p>
<p>因为IO事件分为输入和输出，因此ChannelHandler又具体的分为<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>，分别用于某个阶段输入输出事件的处理。</p>
<p><strong>ChannelHandler的类图继承关系如下：</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486259691612064981.png" alt="Image.png"></p>
<p>对于<code>ChannelHandlerAdapter</code>、<code>ChannelInboundHandlerAdapter</code>、<code>ChannelOutboundHandlerAdapter</code>，从名字就可以看出来其作用是适配器，适配器是一种设计模式。设想一个，一个接口可能定义很多抽象方法，如果子类直接实现，必定要全部实现这些方法，使得代码很臃肿。由于接口中定义的有些方法是公共的，还有一些方法可能是子类并不关心的，因此通过适配器类，这些方法提供默认的实现。这样的话，在编程的时候，子类只需要覆写自己感兴趣的方法即可。</p>
<p>这提示我们，在使用==netty进行编程的时候，对于输入事件的处理，我们应该继承ChannelInboundHandlerAdapter类，而不是直接实现ChannelInboundHandler接口；反之对于输出事件，我们应该继承ChannelOutboundHandlerAdapter类。==</p>
<p>在处理channel的IO事件时，我们通常会分成几个阶段。以读取数据为例，通常我们的处理顺序是：</p>
<blockquote>
<p>处理半包或者粘包问题–&gt;数据的解码(或者说是反序列化)–&gt;数据的业务处理</p>
</blockquote>
<p>可以看到不同的阶段要执行不同的功能，因此通常我们会编写多个ChannelHandler，来实现不同的功能。而且多个ChannelHandler之间的顺序不能颠倒，例如我们必须先处理粘包解包问题，之后才能进行数据的业务处理。</p>
<p><strong>ChannelPipeline</strong></p>
<p>Netty中通过<code>ChannelPipeline</code>来保证ChannelHandler之间的处理顺序。每一个Channel对象创建的时候，都会自动创建一个关联的ChannelPipeline对象，我们可以通过io.netty.channel.Channel对象的<code>pipeline()</code>方法获取这个对象实例。</p>
<p>ChannelPipeline 的具体的创建过程定义<code>AbstractChannel</code>类的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.channel;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();<span class="comment">//创建默认的pipeline</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">pipeline</span><span class="params">()</span> </span>&#123;<span class="comment">//实现Chnannel定义的pipeline方法，返回pipeline实例</span></span><br><span class="line">        <span class="keyword">return</span> pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为ChannelPipleLine的创建是定义在AbstractChannel的构造方法中的，而每个Channel只会被创建一次，只会调用一次构造方法，因此每个Channel实例唯一对应一个ChannelPipleLine 实例。</p>
<p>从上述代码中，我们可以看到ChannelPipleLine的具体创建过程实际上是通过return new DefaultChannelPipeline(this);实现的。<code>DefaultChannelPipeline</code>是ChannelPipeline的默认实现类。</p>
<p>回顾典型的服务端代码的编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                              ch.pipeline().addLast(<span class="keyword">new</span> ChildChannelHandler1());</span><br><span class="line">                              ch.pipeline().addLast(<span class="keyword">new</span> ChildChannelHandler2());</span><br><span class="line">                             &#125;</span><br><span class="line">                           &#125;)</span><br><span class="line">                .bind(port);</span><br></pre></td></tr></table></figure>
<p>上述代码片段在接受到一个SocketChannel的时候，通过initChannel方法来进行初始化，即将我们自定义的ChildChannelHandler1和ChildChannelHandler2添加到SocketChannel关联的ChannelPipeline中。</p>
<p>ChannelPipeline 除了负责配置handler的顺序，还负责在收到读/写事件之后按照顺序调用这些handler。以下左图显示读操作的调用过程，右边的显示了写事件调用过程。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486259922514007599.png" alt="Image.png"></p>
<p>举例来说，假设我们按照如下方式创建了一个ChannelPipeline对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline p = ...;</span><br><span class="line">   p.addLast(<span class="string">"1"</span>, <span class="keyword">new</span> InboundHandlerA());</span><br><span class="line">   p.addLast(<span class="string">"2"</span>, <span class="keyword">new</span> InboundHandlerB());</span><br><span class="line">   p.addLast(<span class="string">"3"</span>, <span class="keyword">new</span> OutboundHandlerA());</span><br><span class="line">   p.addLast(<span class="string">"4"</span>, <span class="keyword">new</span> OutboundHandlerB());</span><br><span class="line">   p.addLast(<span class="string">"5"</span>, <span class="keyword">new</span> InboundOutboundHandlerX());</span><br></pre></td></tr></table></figure>
<p>注：上例中假设InboundHandlerA、InboundHandlerB实现了ChannelInboundHandler接口，OutboundHandlerA、OutboundHandlerB实现了ChannelOutboundHandler接口，InboundOutboundHandlerX同时实现了ChannelInboundHandler和ChannelOutboundHandler接口。前面的1、2、3、4、5并不是handler的编号，而是handler的名字，ChannelPipeline允许在添加handler的时候为其指定一个名字。</p>
<p> 可以看到我们在一个ChannelPipeline钟同时定义了输出和输出事件的处理器。需要注意的是，当一个输入事件来的时候，输出事件处理器是不会发生作用的；反之亦然。因此：</p>
<p> 当一个输入事件来了之后，事件处理器的调用顺序为1,2,5</p>
<p> 当一个输出事件来了之后，事件处理器的处理顺序为5,4,3。(===注意输出事件的处理器发挥作用的顺序与定义的顺序是相反的===)</p>
<p> <strong>需要注意的是：</strong></p>
<p>  1、默认情况下，一个ChannelPipeline实例中，同一个类型ChannelHandler只能被添加一次，如果添加多次，则会抛出异常，具体参见io.netty.channel.DefaultChannelPipeline#checkMultiplicity。如果需要多次添加同一个类型的ChannelHandler的话，则需要在该ChannelHandler实现类上添加@Sharable注解。</p>
<p>  2、在ChannelPipeline中，每一个ChannelHandler都是有一个名字的，而且名字必须的是唯一的，如果名字重复了，则会抛出异常，参见io.netty.channel.DefaultChannelPipeline#checkDuplicateName。</p>
<p>  3、如果添加ChannelHanler的时候没有显示的指定名字，则会按照规则其起一个默认的名字。具体规则如下，如果ChannelPipeline中只有某种类型的handler实例只有一个,如XXXHandler,YYYHandler，则其名字分别为XXXHandler#0，YYYHandler#0，如果同一类型的Handler有多个实例，则每次之后的编号加1。具体可参见io.netty.channel.DefaultChannelPipeline#generateName方法。</p>
<p><strong>ChannelHandlerContext</strong></p>
<p>前面提到可以通过ChannelPipeline的添加方法，按照顺序添加ChannelHandler，并在之后按照顺序进行调用。事实上，每个ChannelHandler会被先封装成<code>ChannelHandlerContext</code>。之后再封装进ChannelPipeline中。</p>
<p>以<code>DefaultChannelPipeline</code>的<code>addLast</code>方法为例，如果查看源码，最终会定位到以下方法：</p>
<p><code>DefaultChannelPipeline#addLast(EventExecutorGroup, String,ChannelHandler)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, <span class="keyword">final</span> String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkDuplicateName(name);<span class="comment">//check这种类型的handler实例是否允许被添加多次</span></span><br><span class="line">       <span class="comment">//将handler包装成一个DefaultChannelHandlerContext类</span></span><br><span class="line">        AbstractChannelHandlerContext newCtx = <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, group, name, handler);</span><br><span class="line">        addLast0(name, newCtx);<span class="comment">//维护AbstractChannelHandlerContext的先后关系</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到的确是先将ChannelHandler当做参数构建成一个DefaultChannelHandlerContext实例之后，再调用<code>addLast0</code>方法维护ChannelHandlerContext的先后关系，从而确定了ChannelHandler的先后关系。</p>
<p>ChannelHandlerContext的类图继承关系如下：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260132790084013.png" alt="Image.png"></p>
<p>ChannelPipeline的默认实现类是DefaultChannelPipeline，ChannelHandlerContext的默认实现类是<code>DefaultChannelHandlerContext</code>。</p>
<p>DefaultChannelPipeline内部是通过一个双向链表记录ChannelHandler的先后关系，而双向链表的节点是<code>AbstractChannelHandlerContext</code>类。</p>
<p>以下是AbstractChannelHandlerContext类的部分源码<strong>(双向链表节点)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerContext</span> <span class="keyword">extends</span> <span class="title">DefaultAttributeMap</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelHandlerContext</span>, <span class="title">ResourceLeakHint</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext next;<span class="comment">//当前节点的上一个节点</span></span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext prev;<span class="comment">//当前节点的下一个节点</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultChannelPipeline内部通过两个哨兵节点HeadContext和TailContext作为链表的开始和结束，熟悉双向链表数据结构的同学，肯定知道，设置哨兵可以在移除节点的时候，不需要判断是否是最后一个节点。相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title">ChannelPipeline</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEAD_NAME = generateName0(HeadContext.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAIL_NAME = generateName0(TailContext.class);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head;<span class="comment">//双向链表的头元素</span></span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail;<span class="comment">//双向列表的尾部元素</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">     ....</span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);<span class="comment">//创建双向链表头部元素实例</span></span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);<span class="comment">//创建双向链表的尾部元素实例</span></span><br><span class="line">    <span class="comment">//设置链表关系</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//设置ChannelHandler的先后顺序关系</span></span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显<code>HeadContext</code>和<code>TailContext</code>除了作为哨兵，还有其他的作用，这个我们稍后介绍。</p>
<p><strong>思考为什么DefaultChannelPipeline不是直接添加ChannelHander到其中，而是通过将其包装成AbstractChannelHandlerContext类后再添加？</strong></p>
<p> 答案很简单，ChannelHandler本身不知道下一个ChannelHandler 是谁，或者有没有下一个ChannelHandler，这些信息需要ChannelPipeline类来维护。只不过DefaultChannelPipeline选择通过链表的方式来记录来实现这个关系。你完全也可以自定义了一个ChannelPipeline的实现，通过其他任何方式来维护,例如通过一个数组。</p>
<p>  另外一个原因是，因为ChannelHander通常是由开发者自己实现的，在回调其方法时，我们可以AbstractChannelHandlerContext给其封装更多的有用的信息。</p>
<p><strong>ChannelHander、ChannelPipeline、ChannelHandlerContext的联合工作过程</strong></p>
<p>前面提到DefaultChannelPipeline是将ChannelHander包装成AbstractChannelHandlerContext类之后，再添加到链表结构中的，从而实现handler的级联调用。</p>
<p>ChannelInboundHandler 接口定义的9个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在ChannelPipeline和ChannelHandlerContext中，都定义了相同的9个以fire开头的方法，如下所示</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260350101064116.png" alt="Image.png"><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170205/1486260368843052054.png" alt="Image.png"></p>
<p>可以发现这两个接口定义的9个方法与ChannelInboundHandler定义的9个方法是一一对应的，只是在定义每个方法的时候，在前面加了1个fire。</p>
<p><strong>从总体上来说，在调用的时候，是按照如下顺序进行的：</strong></p>
<p>1、先是ChannelPipeline中的fireXXX方法被调用</p>
<p>2、ChannelPipeline中的fireXXX方法接着调用ChannelPipeline维护的ChannelHandlerContext链表中的第一个节点即HeadContext 的fireXXX方法</p>
<p>3、ChannelHandlerContext 中的fireXXX方法调用ChannelHandler中对应的XXX方法。由于可能存在多个ChannelHandler，因此每个ChannelHandler的xxx方法又要负责调用下一个ChannelHandlerContext的fireXXX方法，直到整个调用链完成</p>
<p>下面详细介绍每个fire方法被调用的时机</p>
<p><strong>fireChannelRegistered() 和fireChannelActive()是在Channel注册到EventLoop中时调用的，只会被调用一次</strong></p>
<p>相关源码位于：</p>
<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        doRegister();<span class="comment">//注册通道到EventLoop中</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();<span class="comment">//注册成功，调用fireChannelRegistered()</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            pipeline.fireChannelActive();<span class="comment">//如果激活，调用fireChannelActive()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意isActive方法是抽象方法，由子类覆盖，可以查看NioServerSocketChannel和NioSocketChannel的isActive方法，查看这两个通道在什么情况下属于激活状态。</p>
<p>类似的，当取消注册时候<code>fireChannelInactive()</code>、<code>fireChannelUnregistered()</code>会被调用</p>
<p><strong>fireChannelRead(Object msg) 和fireChannelReadComplete()在有数据需要读取的情况下会被触发，可能会被触发多次</strong></p>
<p>相关源码位于io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void read() &#123;</span><br><span class="line">    ....</span><br><span class="line">    try &#123;</span><br><span class="line">        int totalReadAmount = 0;</span><br><span class="line">        boolean readPendingReset = false;</span><br><span class="line">        do &#123;</span><br><span class="line">            ....</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);//有数据要读取，调用fireChannelRead</span><br><span class="line">            ....</span><br><span class="line">        &#125; while (++ messages &lt; maxMessagesPerRead);</span><br><span class="line"> </span><br><span class="line">        pipeline.fireChannelReadComplete();//数据读取完成，调用fireChannelReadComplete()</span><br><span class="line">        ....</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fireExceptionCaught()方法，在读取数据出错的情况下，会被调用</strong></p>
<p>在上述代码片段中，有一个<code>handleReadException</code>方法，表示如果读取数据出错的处理逻辑，其内部会调用fireExceptionCaught()</p>
<p>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#handleReadException</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void handleReadException(ChannelPipeline pipeline,</span><br><span class="line">                        ByteBuf byteBuf, Throwable cause, boolean close) &#123;</span><br><span class="line">    ....</span><br><span class="line">    pipeline.fireExceptionCaught(cause);//出现异常时，调用fireExceptionCaught</span><br><span class="line">    if (close || cause instanceof IOException) &#123;</span><br><span class="line">        closeOnRead(pipeline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fireUserEventTriggered(Object event) 当正在读取数据的时候，如果连接关闭，调用此方法</strong></p>
<p>上述代码片段在处理异常的时候，会判断异常类型是否是IOException或者连接是否关闭，如果是，则调用<code>closeOnRead</code>方法，这个方法内部会调用 fireUserEventTriggered(Object event)</p>
<p>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#closeOnRead</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void closeOnRead(ChannelPipeline pipeline) &#123;</span><br><span class="line">    SelectionKey key = selectionKey();</span><br><span class="line">    setInputShutdown();</span><br><span class="line">    if (isOpen()) &#123;</span><br><span class="line">        if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) &#123;</span><br><span class="line">            key.interestOps(key.interestOps() &amp; ~readInterestOp);</span><br><span class="line">            pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);//调用fireUserEventTriggered方法</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            close(voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>fireChannelWritabilityChanged()方法，当有数据需要输出的时候被调用</strong></p>
<p>相关源码位于：</p>
<p>io.netty.channel.ChannelOutboundBuffer#incrementPendingOutboundBytes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void incrementPendingOutboundBytes(int size) &#123;</span><br><span class="line">    ...</span><br><span class="line">    long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);</span><br><span class="line">    if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</span><br><span class="line">        if (WRITABLE_UPDATER.compareAndSet(this, 1, 0)) &#123;</span><br><span class="line">            channel.pipeline().fireChannelWritabilityChanged();//需要输出数据，调用fireChannelWritabilityChanged()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-0-netty线程模型"><a href="#4-0-netty线程模型" class="headerlink" title="4.0 netty线程模型"></a>4.0 netty线程模型</h1><p>netty是被设计用于支持<code>reactor</code>线程模型的。注意，这里用的是支持，而不是使用了netty，就一定会是reactor线程模型。不过大多数情况下，我们在编写netty应用的时候，很多人就会忽略这些问题，糊里糊涂的用了netty，也不知道自己编写的netty应用属于那种reactor线程模型。    </p>
<p>关于reactor线程模型理解的深刻程度，直接影响了netty服务端程序开发的效率和性能。本文试图通过实战案例(基于netty4.x)，帮助你理解在实际使用netty开发的过程中，如何更好的应用reactor线程模型。</p>
<h2 id="4-1-基本并发编程模型"><a href="#4-1-基本并发编程模型" class="headerlink" title="4.1 基本并发编程模型"></a>4.1 基本并发编程模型</h2><p> 在讲解reactor线程模型之前，我们需要先对基本并发编程模型：串行工作者模型、并发工作者模型进行讲解，因为netty中的reactor线程模型是在这个基础之上演进的，并且，根据我们代码编写的方式，我们的netty应用也有可能是串行工作者模型或者并行工作者模型的。</p>
<p>总的来说：</p>
<blockquote>
<p>串行工作者模型和并行工作者模型关注的是将任务划分为2个阶段：1、任务的接受阶段 2、任务的处理阶段； 而reactor线程模型关注的是上述第二个阶段：任务在处理的过程中，继续划分为多个步骤进行处理下面依次进行讲解</p>
</blockquote>
<p><strong>一、基本并发编程模型</strong></p>
<p><strong>1.1 串行工作者模型</strong></p>
<p>我们以一个典型的任务处理流程，来说明为什么要将任务的<strong>接受流程</strong>与<strong>处理流程</strong>划分开来</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486129913903078046.png" alt="Image.png"></p>
<p>在这个例子中，一个worker线程来处理用户提交的任务，任务的处理步骤粗略的分为：接受任务和处理任务两个阶段。当worker接受到一个任务之后，就立刻进行处理，也就是说任务接受和任务处理是在同一个worker线程中进行的，没有进行区分。这样做存在一个很大的问题是，必须要等待某个task处理完成之后，才能接受处理下一个task。</p>
<p>而通常情况下，任务的处理过程会比任务的接受流程慢得多。例如在处理任务的时候，我们可能会需要访问远程数据库，这属于一种网络IO。通常情况下IO操作是比较耗时的，这直接影响了下一个任务的接受，而且通常在IO操作的时候,CPU是比较空闲的，白白浪费了资源。</p>
<p>因此我们可以考虑将任务的接受与处理分为两个线程进行处理，一个只负责接受任务，一个只负责处理任务。</p>
<p><strong>这就演化出了第一个线程模型：串行工作者模型。如下所示：</strong></p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486129979839014747.png" alt="Image.png"></p>
<p>在这种情况下，接受任务的线程称之为AcceptThread，其将接受到的任务放到一个任务队列中，因此能立即返回接受下一个任务。而worker线程不断的从这个队列中取出任务进行异步执行。</p>
<p>目前这种情况存在一个很大的问题，在于任务处理的太慢，导致队列里积压的任务数量越来愈大，任务不能得到及时的执行。所以我们可以用多个worker thread来处理任务。<strong>这就是串行工作者模型的并发版本-并行工作者模型。</strong></p>
<p><strong>1.2 并行工作者模型</strong></p>
<p><strong>在并行工作者模型中，有一个accpet thread，多个worker thread</strong>，因为worker thread的功能都相同，所以我们通常会将其划分到一个组中(worker thread group) 。</p>
<p>在具体实现上，并行工作者线程模型有两种设计方式，以下分别进行介绍。</p>
<p><strong>并行工作者线程模型设计方式一：基于公共任务队列</strong></p>
<p>accept thread将接受到的任务放到任务队列中，worker thread group中的多个worker thread 并行的从公共的队列中拉取任务进行处理</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130067321058461.png" alt="Image.png"></p>
<p>熟悉java线程池 的用户可能已经发现，可以用ThreadPoolExecutor 来实现右半部分的功能，因为ThreadPoolExecutor 就是多个线程从一个公共的任务队列中拉取任务进行执行。通过在main线程中接受任务，将任务提交到线程池中，即可以完成上述线程模型。</p>
<p><strong>并行工作者线程模型设计方式二：每个worker thread维护自己的任务队列</strong></p>
<p>在第一种方式中，由于多个worker线程同时从一个公共的任务队列中拉取任务进行处理，因此必须要进行加锁，因而影响了效率。因此又有了下面一种设计方式：reactor thread直接将任务转发给各个worker thread，<strong>每个worker thread内部维护一个队列来处理</strong>，如下图</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130113709043975.png" alt="Image.png"></p>
<p>这种方式的设计，避免的锁竞争，因为每个worker thread都从各自的队列中取出任务进行执行。<strong>实际上，netty的实现中，就是为每个worker thread维护了一个队列。</strong></p>
<p>需要注意的是：==由于现在是accpet thread直接给过个worker thread转发任务，任务分配的平均的责任就落到了reactor thread的身上==。 </p>
<h2 id="4-2-Reactor线程模型"><a href="#4-2-Reactor线程模型" class="headerlink" title="4.2 Reactor线程模型"></a>4.2 Reactor线程模型</h2><p>首先要需要说明的是，reactor线程模型并不是netty所独有，其是一种并发编程模型，更确切的或者说一种思想，其具有的是指导意义，开发者需要在这种编程模型思想的指导下，结合自己的实际场景，来进行合理的设计。在不同的场景下，可能设计出来的reactor线程模型是不一样的，例如scala中的akka框架，就是基于reactor线程模型的思想设计的。<strong>换句话说，netty只是结合了nio网络编程的特点，合理的应用了reactor线程模型</strong>。关于netty是如何合理的利用reactor线程模型，将在之后讲解。</p>
<p>现在我们还是需要简单的介绍一下有哪些典型的reactor线程模型设计方式。回顾串行工作者模型和并行工作者模型，它们主要的关注点是：划分任务的接受阶段与任务的处理阶段。也正是因为如此，我们通常将接受任务的线程称之为<code>Accpet Thread</code>。而任务的处理过程都是一个线程(<code>worker thread</code>)内完成的。</p>
<p>reactor线程模型关注的是：任务接受之后，对处理过程继续进行切分，划分为多个不同的步骤，每个步骤用不同的线程来处理，也就是原本由一个线程处理的任务现在由多个线程来处理，每个线程在处理完自己的步骤之后，还需要将任务转发到线程继续进行处理。为了进行区分，在reactor线程模型中，处理任务并且分发的线程，不再称之为worker thread，而是<code>reactor thread</code>。</p>
<p><strong>2.1 单线程reactor线程模型</strong></p>
<p>下图演示了单线程reactor线程模型，之所以称之为单线程，还是因为只有一个accpet Thread接受任务，之后转发到reactor线程中进行处理。两个黄色框表示的是Reactor Thread Group，里面有多个Reactor Thread。一个Reactor Thread Group中的Reactor Thread功能都是相同的，例如第一个黄色框中的Reactor Thread都是处理拆分后的任务的第一阶段，第二个黄色框中的Reactor Thread都是处理拆分后的任务的第二步骤。任务具体要怎么拆分，要结合具体场景，下图只是演示作用。<strong>一般来说，都是以比较耗时的操作(例如IO)为切分点</strong>。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130350803068991.png" alt="Image.png"></p>
<p>特别的，如果我们在任务处理的过程中，不划分为多个阶段进行处理的话，那么单线程reactor线程模型就退化成了并行工作和模型。<strong>事实上，可以认为并行工作者模型，就是单线程reactor线程模型的最简化版本。</strong></p>
<p><strong>2.2 多线程reactor线程模型</strong></p>
<p>所谓多线程reactor线程模型，无非就是有多个accpet线程，如下图中的虚线框中的部分。</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130401975018511.png" alt="Image.png"></p>
<p><strong>2.3</strong> <strong>混合型reactor线程模型</strong></p>
<p> 混合型reactor线程模型，实际上最能体现reactor线程模型的本质：</p>
<ul>
<li>将任务处理切分成多个阶段进行，每个阶段处理完自己的部分之后，转发到下一个阶段进行处理。不同的阶段之间的执行是异步的，可以认为每个阶段都有一个独立的线程池。</li>
<li>不同的类型的任务，有着不同的处理流程，划分时需要划分成不同的阶段。如下图蓝色是一种任务、绿色是另一种任务，两种任务有着不同的执行流程</li>
</ul>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130497191094359.png" alt="Image.png"></p>
<h2 id="4-3-Netty对Reactor线程模型的应用"><a href="#4-3-Netty对Reactor线程模型的应用" class="headerlink" title="4.3 Netty对Reactor线程模型的应用"></a>4.3 Netty对Reactor线程模型的应用</h2><p>上面提到的几种线程模型，在我们编写的基于netty的应用中都有可能出现，甚至可能会不用reactor线程。具体属于哪一种情况，要看我们的代码是如何编写的。</p>
<p>我们先以一个使用了reactor线程模型的netty服务端的典型代码进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">3</span>);</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); </span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br><span class="line">.handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">      .attr(AttributeKey.valueOf(<span class="string">"ssc.key"</span>),<span class="string">"scc.value"</span>)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">            .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); </span><br><span class="line">        .childAttr(AttributeKey.valueOf(<span class="string">"sc.key"</span>),<span class="string">"sc.value"</span>)</span><br><span class="line">        .bind(port);</span><br></pre></td></tr></table></figure>
<p>在上述代码片段中代码很少，却包含了一个复杂reactor线程模型，如下所示：</p>
<p><img src="http://static.tianshouzhi.com/ueditor/upload/image/20170203/1486130747296085576.png" alt="Image.png"></p>
<p> 图中大致包含了5个步骤，而我们编写的服务端代码中可能并不能完全体现这样的步骤，因为Netty将其中一些步骤的细节隐藏了，笔者将会通过图形分析与源码分析相结合的方式帮助读者理解这五个步骤。这个五个步骤可以按照以下方式简要概括：</p>
<ol>
<li>设置服务端ServerBootStrap启动参数</li>
<li>通过ServerBootStrap的bind方法启动服务端，bind方法会在parentGroup中注册NioServerScoketChannel，监听客户端的连接请求</li>
<li>Client发起连接CONNECT请求，parentGroup中的NioEventLoop不断轮循是否有新的客户端请求，如果有，ACCEPT事件触发</li>
<li>ACCEPT事件触发后，parentGroup中NioEventLoop会通过NioServerSocketChannel获取到对应的代表客户端的NioSocketChannel，并将其注册到childGroup中</li>
<li>childGroup中的NioEventLoop不断检测自己管理的NioSocketChannel是否有读写事件准备好，如果有的话，调用对应的ChannelHandler进行处理</li>
</ol>
<p><strong>需要提醒的是，这五个步骤是笔者自己的总结，主要是为了方便理解，并不是官方的划分。</strong></p>
<p>下面我们开始详细介绍每一个步骤：</p>
<p><strong>1、设置服务端ServerBootStrap启动参数</strong></p>
<p>ServerBootStrap继承自AbstractBootstrap，其代表服务端的启动类，当调用其bind方法时，表示启动服务端。在启动之前，我们会调用group，channel、handler、option、attr、childHandler、childOption、childAttr等方法来设置一些启动参数。</p>
<p><strong>group方法：</strong></p>
<p>group可以认为是设置执行任务的线程池，在Netty中，EventLoopGroup 的作用类似于线程池，每个EventLoopGroup中包含多个EventLoop对象，代表不同的线程。特别的，我们创建的是2个EventLoopGroup的子类NioEventLoopGroup的实例：parentGroup、childGroup， 所以实际上包含的是多个NioEventLoop对象。从名字上就可以看出，二者是专门用于处理java nio事件的，某种程度上这也验证了我们前面的提到的Netty中的reactor线程模型是结合java nio编程特点来设计的说法。</p>
<p>在创建parentGroup 、childGroup 时，分别传入了构造参数1和3，这对应了上图中红色部分的parentGroup 中只有1个NioEventLoop，绿色部分的childGroup 中有3个NioEventLoop。</p>
<p>特别的，如果我们创建NioEventLoopGroup 的时候，没有指定参数，或者传入的是0，那么这个NioEventLoopGroup包含的NioEventLoop个数将会是：cpu核数*2。</p>
<p>具体可参见NioEventLoopGroup的父类MultithreadEventLoopGroup构造时的相关代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;<span class="comment">//默认线程数量，cpu核数*2.......static &#123;    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(            "io.netty.eventLoopThreads", Runtime.getRuntime().availableProcessors() * 2));     if (logger.isDebugEnabled()) &#123;        logger.debug("-Dio.netty.eventLoopThreads: &#123;&#125;", DEFAULT_EVENT_LOOP_THREADS);    &#125;&#125; protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123;    super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);&#125;.......&#125;</span></span><br></pre></td></tr></table></figure>
<p>在创建完parentGroup 和childGroup 之后，我们把其当做参数传递给了ServerBootStrap,通过调用带有2个参数的group方法。在这个方法中，会把parentGroup 当做参数传递给ServerBootStrap的父类AbstractBootstrap来进行维护，childGroup 则由ServerBootStrap自己维护。</p>
<p>之后，我们可以调用ServerBootStrap 的group()方法来获取parentGroup 的引用，这个方法父类AbstractBootstrap继承的。另外可以通过调用ServerBootStrap自己定义的childGroup()方法来获取workerGroup的引用。</p>
<p>相关代码如下：</p>
<p>io.netty.bootstrap.ServerBootstrap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt; </span>&#123;..........<span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;<span class="comment">//ServerBootStrap自己维护childGroup..........public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;    super.group(parentGroup);//将parentGroup传递给父类AbstractBootstrap处理    if (childGroup == null) &#123;        throw new NullPointerException("childGroup");    &#125;    if (this.childGroup != null) &#123;        throw new IllegalStateException("childGroup set already");    &#125;    this.childGroup = childGroup;//给childGroup赋值    return this;&#125;.......  public EventLoopGroup childGroup() &#123;//获取childGroup    return childGroup;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>io.netty.bootstrap.AbstractBootstrap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;......<span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup group;<span class="comment">//这个字段将会被设置为parentGroup......public B group(EventLoopGroup group) &#123;    if (group == null) &#123;        throw new NullPointerException("group");    &#125;    if (this.group != null) &#123;        throw new IllegalStateException("group set already");    &#125;    this.group = group;    return (B) this;&#125;......public final EventLoopGroup group() &#123;//获取parentGroup    return group;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>channel方法：</strong></p>
<p>channel继承自AbstractBootstrap，用于构造通道的工厂类ChannelFactory实例，在之后需要创建通道实例，例如NioServerSocketChannel的时候，通过调用ChannelFactory.newChannel()方法来创建。</p>
<p>channel方法内部隐含的调用了channelFactory方法，我们也可以直接调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;........<span class="comment">//这个工厂类最终创建的通道实例，就是channel方法指定的NioServerSocketChannelprivate volatile ChannelFactory&lt;? extends C&gt; channelFactory;..........public B channel(Class&lt;? extends C&gt; channelClass) &#123;    ......    return channelFactory(new BootstrapChannelFactory&lt;C&gt;(channelClass));&#125;public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123;    ..........    this.channelFactory = channelFactory;    return (B) this;&#125;.......final ChannelFactory&lt;? extends C&gt; channelFactory() &#123;    return channelFactory;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>细心的读者会发现，除了channel、group方法之外，其他三个方法都是一 一对应的:</p>
<ul>
<li>handler–&gt;childHandler ：分别用于设置NioServerSocketChannel和NioSocketChannel的处理器链，也就是当有一个NIO事件的时候，应该按照怎样的步骤进行处理。</li>
<li>option–&gt;childOption：分别用于设置NioServerSocketChannel和 NioSocketChannel的TCP连接参数，在ChannelOption类中可以看到Netty支持的所有TCP连接参数。</li>
<li>attr–&gt;childAttr：用于给channel设置一个key/value，之后可以根据key获取</li>
</ul>
<p><strong>其中：</strong></p>
<p>  handler、option、attr方法，都是从AbstractBootstrap中继承的。这些方法设置的参数，将会被应用到NioServerSocketChannel实例上，由于NioServerSocketChannel一般只会创建一个，因此这些参数通常只会应用一次。源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;  ...    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = <span class="keyword">new</span> LinkedHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();   <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler handler;...<span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;    ....    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> BootstrapChannelFactory&lt;C&gt;(channelClass));&#125;<span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;    .......    <span class="keyword">this</span>.channelFactory = channelFactory;    <span class="keyword">return</span> (B) <span class="keyword">this</span>;&#125;<span class="function"><span class="keyword">final</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> handler;&#125;<span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;.....&#125;<span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span></span>&#123;...&#125;<span class="comment">//设置ChannelOption参数final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options()&#123;return options;&#125;//获取ChannelOption参数public &lt;T&gt; B attr(AttributeKey&lt;T&gt; key, T value)&#123;.....&#125; //设置属性final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs() &#123;return attrs;&#125;//获取属性&#125;</span></span><br></pre></td></tr></table></figure>
<p>childHandler、childOption、childAttr方法是ServerBootStrap自己定义的,这些方法设置的参数，将会被应用到NioSocketChannel实例上，由于服务端每次接受到一个客户端连接，就会创建一个NioSocketChannel实例，因此每个NioSocketChannel实例都会应用这些方法设置的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt; </span>&#123;...........<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> LinkedHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();<span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;<span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;    <span class="keyword">super</span>.group(parentGroup);    ....    <span class="keyword">this</span>.childGroup = childGroup;    <span class="keyword">return</span> <span class="keyword">this</span>;&#125;<span class="keyword">public</span> &lt;T&gt; <span class="function">ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span> </span>&#123;...&#125; <span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;......&#125;..............&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2 调用ServerBootStrap的bind方法</strong></p>
<p><strong>调用bind方法，就相当于启动了服务端。启动的核心逻辑都是在bind方法中。</strong></p>
<p>bind方法内部，会创建一个NioServerSocketChannel实例，并将其在parentGroup中进行注册，注意这个过程对用户屏蔽了。</p>
<p>parentGroup在接受到注册请求时，会从自己的管理的NioEventLoop中，选择一个进行注册。由于我们的案例中，parentGroup只有一个NioEventLoop，因此只能注册到这个上。</p>
<p>一旦注册完成，我们就可以通过NioServerSocketChannel检测有没有新的客户端连接的到来。</p>
<p>如果一步一步追踪ServerBootStrap.bind方法的调用链，最终会定位到ServerBootStrap 父类AbstractBootstrap的doBind方法，相关源码如下：</p>
<p>io.netty.bootstrap.AbstractBootstrap#doBind</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();<span class="comment">//初始化NioServerSocketChannel，并注册到bossGroup中    ....//省略    return promise;</span></span><br></pre></td></tr></table></figure>
<p>doBind方法中，最重要的调用的方法是initAndRegister，这个方法主要完成3个任务</p>
<p>1、创建NioServerSocketChannel实例，这是通过之前创建的ChannelFactory实例的newChannel方法完成</p>
<p>2、初始化NioServerSocketChannel，即将我们前面通过handler，option，attr等方法设置的参数应用到NioServerSocketChannel上</p>
<p>3、将NioServerSocketChannel 注册到parentGroup中，parentGroup会选择其中一个NioEventLoop来运行这个NioServerSocketChannel要完成的功能，即监听客户端的连接。</p>
<p>以下是io.netty.bootstrap.AbstractBootstrap#initAndRegister的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;    <span class="keyword">final</span> Channel channel = channelFactory().newChannel();<span class="comment">//1、创建NioServerSocketChannel实例    try &#123;        init(channel);//2、初始化NioServerSocketChannel，这是一个抽象方法，ServerBootStrap对此进行了覆盖    &#125; catch (Throwable t) &#123;        channel.unsafe().closeForcibly();        return channel.newFailedFuture(t);    &#125;     ChannelFuture regFuture = group().register(channel);//3、NioServerSocketChannel注册到parentGroup中    if (regFuture.cause() != null) &#123;        if (channel.isRegistered()) &#123;            channel.close();        &#125; else &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;     return regFuture;&#125;</span></span><br></pre></td></tr></table></figure>
<p>ServerBootStrap实现了AbstractBootstrap的抽象方法init，对NioServerSocketChannel进行初始化。熟悉设计模式的同学会意识到，这是典型的模板设计模式，即父类运行过程中会调用多个方法，子类对特定的方法进行覆写。</p>
<p>在这里，init方法主要是为NioServerSocketChannel设置运行参数，也就是我们前面通过调用ServerBootStrap的option、attr、handler等方法指定的参数。</p>
<p>特别需要注意的是，除了我们通过handler方法为NioServerSocketChannel 指定的ChannelHandler之外(在我们这里是LoggingHandler)，ServerBootStrap的init方法总是会帮我们在NioServerSocketChannel 的处理器链的最后添加一个默认的处理器ServerBootstrapAcceptor。</p>
<p>从ServerBootstrapAcceptor 名字上可以看出来，其是客户端连接请求的处理器。当接受到一个客户端请求之后，Netty会将创建一个代表客户端的NioSocketChannel对象。而我们通过ServerBoodStrap指定的channelHandler、childOption、childAtrr、childGroup等参数，也需要设置到NioSocketChannel中。但是明显现在，由于只是服务端刚启动，没有接收到任何客户端请求，还没有认为NioSocketChannel实例，因此这些参数要保存到ServerBootstrapAcceptor中，等到接收到客户端连接的时候，再将这些参数进行设置，我们可以看到这些参数通过构造方法传递给了ServerBootstrapAcceptor。</p>
<p>源码如下所示：</p>
<p>io.netty.bootstrap.ServerBootstrap#init</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Overridevoid</span> init(Channel channel) <span class="keyword">throws</span> Exception &#123;<span class="comment">//channel参数类型就是NioServerSocketChannel   //1、为NioServerSocketChannel设置option方法设置的参数   final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options();    synchronized (options) &#123;        channel.config().setOptions(options);    &#125;   //2、为NioServerSocketChannel设置attr方法设置的参数    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs();    synchronized (attrs) &#123;        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;            @SuppressWarnings("unchecked")            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();            channel.attr(key).set(e.getValue());        &#125;    &#125;    //3、为NioServerSocketChannel设置通过handler方法指定的处理器    ChannelPipeline p = channel.pipeline();    if (handler() != null) &#123;        p.addLast(handler());    &#125;     //4、为NioSocketChannel设置默认的处理器ServerBootstrapAcceptor，并将相关参数通过构造方法传给ServerBootstrapAcceptor    final EventLoopGroup currentChildGroup = childGroup;    final ChannelHandler currentChildHandler = childHandler;    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;    synchronized (childOptions) &#123;        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));    &#125;    synchronized (childAttrs) &#123;        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));    &#125;     p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;        @Override        public void initChannel(Channel ch) throws Exception &#123;            ch.pipeline().addLast(new ServerBootstrapAcceptor(                    currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));        &#125;    &#125;);&#125;</span></span><br></pre></td></tr></table></figure>
<p>io.netty.channel.EventLoopGroup#register方法</p>
<p> 在初始化完成之后，ServerBootStrap通过调用register方法将NioServerSocketChannel注册到了parentGroup中。</p>
<p> 从较高的层面来说，parentGroup 的类型是NioEventLoopGroup，一个NioEventLoopGroup可能会管理多个NioEventLoop，对于通道的注册，NioEventLoopGroup会从多个NioEventLoop中选择一个来执行真正的注册。之后这个通道的nio事件，也都是由这个NioEventLoop来处理。也就是说，一个通道只能由一个NioEventLoop来处理，一个NioEventLoop可以处理多个通道，通道与NioEventLoop是多对一的关系。</p>
<p> NioEventLoopGroup的register方法继承自MultithreadEventLoopGroup。</p>
<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;.......<span class="meta">@Overridepublic</span> <span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;    <span class="keyword">return</span> next().register(channel);&#125;.......&#125;</span><br></pre></td></tr></table></figure>
<p>next方法的返回值，就是NioEventLoop，可以看到，真正的注册工作，是NioEventLoop完成的。next()方法还提供了通道在NioEventLoop中平均分配的机制。</p>
<p>NioEventLoopGroup创建的时候，其父类MultithreadEventExecutorGroup中会创建一个EventExecutorChooser实例，之后通过其来保证通道平均注册到不同的NioEventLoop中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadEventExecutorGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> </span>&#123;....<span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;<span class="comment">//NioEventLoop是EventExecutor的子类，这里的children指的就是NioEventLoopprivate final AtomicInteger childIndex = new AtomicInteger();//上一次接受注册任务的EventEexcutor编号private final EventExecutorChooser chooser;...protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123;......children = new SingleThreadEventExecutor[nThreads];if (isPowerOfTwo(children.length)) &#123;//如果指定的线程数是2的幂    chooser = new PowerOfTwoEventExecutorChooser();&#125; else &#123;    chooser = new GenericEventExecutorChooser();//按照round-robin的方式，来保证平均&#125;for (int i = 0; i &lt; nThreads; i ++) &#123;    boolean success = false;    try &#123;//创建EventExecutor实例，注意newChild是抽象方法，NioEventLoopGroup对此方法进行了覆盖，返回的实例是NioEventLoop。        children[i] = newChild(threadFactory, args);        success = true;    &#125; catch (Exception e) &#123; .............  &#125;&#125;......&#125;//调用此方法，即可以保证任务的平均分配@Overridepublic EventExecutor next() &#123;    return chooser.next();&#125;private final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser &#123;    @Override    public EventExecutor next() &#123;        return children[childIndex.getAndIncrement() &amp; children.length - 1];    &#125;&#125; private final class GenericEventExecutorChooser implements EventExecutorChooser &#123;    @Override    public EventExecutor next() &#123;        return children[Math.abs(childIndex.getAndIncrement() % children.length)];    &#125;&#125;............ &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.tianshouzhi.com/api/tutorials/netty/221" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/netty/221</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/05/Memcached笔记/" rel="next" title="Memcached笔记">
                <i class="fa fa-chevron-left"></i> Memcached笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/08/Spring总结/" rel="prev" title="Spring总结">
                Spring总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2018/09/05/Netty/Netty-入门/" data-title="Netty 入门" data-url="http://yoursite.com/2018/09/05/Netty/Netty-入门/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Dylan Lang">
            
              <p class="site-author-name" itemprop="name">Dylan Lang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">513</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">120</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-Unix五种IO模型与Java-IO模型演进"><span class="nav-number">1.</span> <span class="nav-text">0 Unix五种IO模型与Java IO模型演进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Blocking-IO"><span class="nav-number">1.1.</span> <span class="nav-text">1、Blocking IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、非阻塞式I-O"><span class="nav-number">1.2.</span> <span class="nav-text">2、非阻塞式I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-I-O多路复用"><span class="nav-number">1.3.</span> <span class="nav-text">3 I/O多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-信号驱动式I-O"><span class="nav-number">1.4.</span> <span class="nav-text">4 信号驱动式I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-异步I-O"><span class="nav-number">1.5.</span> <span class="nav-text">5 异步I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-BIO编程与其局限性"><span class="nav-number">2.</span> <span class="nav-text">1 BIO编程与其局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO编程的局限性"><span class="nav-number">2.1.</span> <span class="nav-text">BIO编程的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-NIO-Buffer"><span class="nav-number">3.</span> <span class="nav-text">2 NIO Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-缓冲区基础"><span class="nav-number">3.1.</span> <span class="nav-text">1 缓冲区基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-缓冲区API"><span class="nav-number">3.2.</span> <span class="nav-text">2 缓冲区API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-创建缓冲区"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 创建缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-缓冲区存取"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 缓冲区存取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Channel"><span class="nav-number">4.</span> <span class="nav-text">3 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Channel简介"><span class="nav-number">4.1.</span> <span class="nav-text">1 Channel简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Socket通道详解"><span class="nav-number">4.2.</span> <span class="nav-text">2 Socket通道详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-ServerSocketChannel"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1 ServerSocketChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-SocketChannel"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2 SocketChannel</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Channel案例"><span class="nav-number">5.</span> <span class="nav-text">3 Channel案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Selector"><span class="nav-number">6.</span> <span class="nav-text">5 Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-选择器基础"><span class="nav-number">6.1.</span> <span class="nav-text">1 选择器基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-创建选择器"><span class="nav-number">6.1.1.</span> <span class="nav-text">1.1 创建选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-注册通道到选择器上"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">1.2.1 注册通道到选择器上</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-选择键-SelectionKey"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">1.2.1 选择键(SelectionKey)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-使用选择器"><span class="nav-number">6.2.</span> <span class="nav-text">1.2 使用选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-选择过程"><span class="nav-number">6.2.1.</span> <span class="nav-text">1.2.1 选择过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-停止选择过程"><span class="nav-number">6.3.</span> <span class="nav-text">1.2.2 停止选择过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-管理选择键"><span class="nav-number">6.4.</span> <span class="nav-text">1.3.3 管理选择键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-并发性"><span class="nav-number">6.5.</span> <span class="nav-text">1.4 并发性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-异步关闭能力"><span class="nav-number">6.6.</span> <span class="nav-text">1.5 异步关闭能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-选择过程的可扩展性"><span class="nav-number">6.7.</span> <span class="nav-text">1.6 选择过程的可扩展性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-基于Selector-Channel-线程池的Timeserver"><span class="nav-number">7.</span> <span class="nav-text">6 基于Selector+Channel+线程池的Timeserver</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#2-0-Netty入门案例"><span class="nav-number"></span> <span class="nav-text">2.0 Netty入门案例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-0-Channel"><span class="nav-number"></span> <span class="nav-text">3.0 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-ChannelConfig"><span class="nav-number">1.</span> <span class="nav-text">3.1 ChannelConfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-ChannelHander"><span class="nav-number">2.</span> <span class="nav-text">3.2 ChannelHander</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-0-netty线程模型"><span class="nav-number"></span> <span class="nav-text">4.0 netty线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-基本并发编程模型"><span class="nav-number">1.</span> <span class="nav-text">4.1 基本并发编程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Reactor线程模型"><span class="nav-number">2.</span> <span class="nav-text">4.2 Reactor线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Netty对Reactor线程模型的应用"><span class="nav-number">3.</span> <span class="nav-text">4.3 Netty对Reactor线程模型的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number"></span> <span class="nav-text">参考文献</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dylan Lang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
